<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Gioco Bandiere 1 vs 1 Online</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #e0f2ff, #e5e7eb);
    }

    .app {
      background: white;
      border-radius: 24px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.12);
      padding: 20px;
      max-width: 720px;
      width: 100%;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 1.5rem;
    }

    .subtitle {
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: #6b7280;
    }

    .top-row {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .card {
      border-radius: 16px;
      border: 1px solid #e5e7eb;
      padding: 10px 12px;
      background: #f9fafb;
      flex: 1;
      min-width: 220px;
    }

    .small-card {
      max-width: 200px;
      flex: 0 0 auto;
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .mode-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.85rem;
    }

    .mode-row label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    input[type="text"] {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
      background: white;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 7px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #111827;
      color: white;
      white-space: nowrap;
    }

    button.secondary {
      background: white;
      border: 1px solid #d1d5db;
      color: #111827;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .status {
      font-size: 0.8rem;
      color: #6b7280;
      min-height: 1.2em;
    }

    .game-container {
      margin-top: 8px;
      border-radius: 18px;
      border: 1px solid #e5e7eb;
      padding: 14px;
      background: #f3f4f6;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.9rem;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      background: #eff6ff;
      color: #1d4ed8;
      font-weight: 600;
    }

    .scores {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .score-card {
      flex: 1;
      border-radius: 12px;
      padding: 8px 10px;
      background: #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
    }

    .score-card.active {
      background: #dbeafe;
      border: 1px solid #3b82f6;
    }

    .score-name {
      font-weight: 600;
    }

    .score-value {
      font-size: 1.1rem;
      font-weight: 700;
    }

    .battle-status {
      font-size: 0.85rem;
      margin-bottom: 10px;
      padding: 6px 8px;
      border-radius: 10px;
      background: #e5e7eb;
    }

    .flag-card {
      border-radius: 14px;
      border: 1px solid #e5e7eb;
      padding: 10px;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 8px;
    }

    .flag-card h2 {
      margin: 0 0 6px 0;
      font-size: 0.95rem;
      font-weight: 600;
      color: #374151;
      text-align: center;
    }

    .flag-wrapper {
      width: 100%;
      max-width: 260px;
      aspect-ratio: 3 / 2;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 6px;
    }

    .flag-wrapper img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }

    .options {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 6px;
      width: 100%;
    }

    .option-btn {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-size: 0.9rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s;
      text-align: center;
      color: #111827;
      font-weight: 600;
    }

    .option-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.08);
    }

    .option-btn.correct {
      background: #bbf7d0;
      border-color: #16a34a;
    }

    .option-btn.wrong {
      background: #fecaca;
      border-color: #dc2626;
    }

    .option-btn:disabled {
      cursor: default;
      opacity: 0.8;
    }

    .game-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: #4b5563;
      gap: 8px;
      flex-wrap: wrap;
    }

    .message {
      min-height: 1.2em;
    }

    @media (max-width: 640px) {
      .app {
        border-radius: 0;
        min-height: 100vh;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1 id="appTitle">Gioco delle Bandiere üåç</h1>
    <div class="subtitle" id="subtitleText">
      Modalit√† <strong>1 vs 1 online</strong> e <strong>Battle Royale</strong> con stanze private.
    </div>

    <div class="mode-row">
      <span id="modeLabelTitle">Modalit√†:</span>
      <label>
        <input type="radio" name="mode" value="duel" checked />
        <span id="modeLabelDuel">1 vs 1</span>
      </label>
      <label>
        <input type="radio" name="mode" value="battle" />
        <span id="modeLabelBattle">Battle Royale</span>
      </label>
    </div>

    <div class="top-row">
      <div class="card">
        <div class="card-title" id="createCardTitle">1. Crea stanza</div>
        <div class="row">
          <button id="createRoomBtn">Crea stanza</button>
          <span id="roomCodeLabel" style="font-size:0.9rem; font-weight:600;"></span>
        </div>
        <div class="status" id="createStatus"></div>
      </div>

      <div class="card">
        <div class="card-title" id="joinCardTitle">2. Entra in stanza</div>
        <div class="row">
          <input type="text" id="joinCodeInput" placeholder="Codice stanza (es. 4821)" />
          <button id="joinRoomBtn" class="secondary">Entra</button>
        </div>
        <div class="status" id="joinStatus"></div>
      </div>

      <div class="card small-card">
        <div class="card-title" id="languageCardTitle">Lingua</div>
        <select id="languageSelect">
          <option value="it">Italiano</option>
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
          <option value="fr">Fran√ßais</option>
          <option value="de">Deutsch</option>
          <option value="pt">Portugu√™s</option>
          <option value="zh">‰∏≠Êñá</option>
          <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
          <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
          <option value="ru">–†—É—Å—Å–∫–∏–π</option>
        </select>
      </div>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
      <div class="header">
        <div>
          <span id="playerTextLabel">Giocatore:</span>
          <strong id="playerLabel"></strong>
          ‚Ä¢
          <span id="roomTextLabel">Stanza:</span>
          <strong id="roomCodeDisplay"></strong>
        </div>
        <div class="badge" id="turnBadge">Turno: -</div>
      </div>

      <div class="scores" id="scoresDuel">
        <div class="score-card" id="scoreP1">
          <span class="score-name" id="scoreName1">Giocatore 1</span>
          <span class="score-value" id="score1">0</span>
        </div>
        <div class="score-card" id="scoreP2">
          <span class="score-name" id="scoreName2">Giocatore 2</span>
          <span class="score-value" id="score2">0</span>
        </div>
      </div>

      <div class="battle-status" id="battleStatus" style="display:none;"></div>

      <div class="flag-card">
        <h2 id="questionTitle">In attesa dell'altro giocatore...</h2>
        <div class="flag-wrapper">
          <img id="flagImg" src="" alt="Bandiera" />
        </div>
        <div class="options" id="optionsContainer"></div>
      </div>

      <div class="game-footer">
        <div class="message" id="gameMessage"></div>
        <button id="leaveBtn" class="secondary">Esci dalla stanza</button>
      </div>
    </div>
  </div>

  <!-- Firebase compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
    // === Firebase ===
    const firebaseConfig = {
      apiKey: "AIzaSyCS2yJAOJvjzgRjwfy8KkWLFN_Yc9nJRpE",
      authDomain: "flags-game-1-vs-1.firebaseapp.com",
      databaseURL: "https://flags-game-1-vs-1-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "flags-game-1-vs-1",
      storageBucket: "flags-game-1-vs-1.firebasestorage.app",
      messagingSenderId: "35708843440",
      appId: "1:35708843440:web:08c2953678946dbc8f5275",
      measurementId: "G-21MV1D94MD"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // === I18N ===
    const translations = {
      it: {
        title: "Gioco delle Bandiere üåç",
        subtitle: "Modalit√† <strong>1 vs 1 online</strong> e <strong>Battle Royale</strong> con stanze private.",
        modeTitle: "Modalit√†:",
        modeDuel: "1 vs 1",
        modeBattle: "Battle Royale",
        languageCardTitle: "Lingua",
        createCardTitle: "1. Crea stanza",
        joinCardTitle: "2. Entra in stanza",
        createBtn: "Crea stanza",
        joinBtn: "Entra",
        joinPlaceholder: "Codice stanza (es. 4821)",
        leaveBtn: "Esci dalla stanza",
        playerText: "Giocatore:",
        roomText: "Stanza:",
        scorePlayer1: "Giocatore 1",
        scorePlayer2: "Giocatore 2",
        turnLabel: "Turno: Giocatore {n}",
        badgeBattle: "Battle Royale",
        badgeFinished: "Partita finita",
        waitingOtherPlayer: "In attesa dell'altro giocatore...",
        waitingBothPlayers: "In attesa che entrambi i giocatori entrino...",
        waitingStart: "In attesa di iniziare...",
        waitingPlayersBattle: "In attesa dei giocatori per la Battle Royale...",
        waitingStartBattle: "La Battle Royale sta per iniziare...",
        statusCreatingRoom: "Creo stanza...",
        statusCreateSuccessDuel: "Stanza creata! Aspetta che entri il Giocatore 2.",
        statusCreateSuccessBattle: "Stanza Battle Royale creata! Condividi il codice con gli amici.",
        statusCreateError: "Errore nella creazione stanza.",
        statusJoinNeedCode: "Inserisci un codice stanza.",
        statusJoinSearching: "Cerco stanza...",
        statusJoinNotFound: "Stanza non trovata.",
        statusJoinFull: "La stanza √® gi√† piena.",
        statusJoinFinished: "Questa partita √® gi√† finita.",
        statusJoinSuccess: "Sei entrato nella stanza!",
        statusJoinError: "Errore nell'ingresso in stanza.",
        roomClosed: "La stanza √® stata chiusa.",
        question: "Di quale paese √® questa bandiera?",
        questionBattle: "Indovina la bandiera: chi sbaglia √® eliminato!",
        msgTurnOtherPlayer: "Turno dell'altro giocatore.",
        msgCorrect: "Giusto! üéâ",
        msgWrong: "Sbagliato! Era: ",
        msgCorrectBattle: "Giusto! Rimani in gioco. üéâ",
        msgWrongBattle: "Sbagliato! Sei eliminato.",
        leftRoom: "Sei uscito dalla stanza.",
        battleStatus: "Giocatori vivi: {alive} / {total}",
        battleWinner: "Vince il Giocatore {n}!",
        battleNoWinner: "Nessun vincitore.",
        youWin: "Hai vinto la Battle Royale! üèÜ",
        youLose: "Sei stato eliminato dalla Battle Royale.",
        youEliminated: "Sei stato eliminato. Puoi guardare il resto della partita.",
        playerUnknown: "-",
        playerLabelBase: "Giocatore"
      },
      en: {
        title: "Flag Game üåç",
        subtitle: "Online <strong>1 vs 1</strong> and <strong>Battle Royale</strong> modes with private rooms.",
        modeTitle: "Mode:",
        modeDuel: "1 vs 1",
        modeBattle: "Battle Royale",
        languageCardTitle: "Language",
        createCardTitle: "1. Create room",
        joinCardTitle: "2. Join room",
        createBtn: "Create room",
        joinBtn: "Join",
        joinPlaceholder: "Room code (e.g. 4821)",
        leaveBtn: "Leave room",
        playerText: "Player:",
        roomText: "Room:",
        scorePlayer1: "Player 1",
        scorePlayer2: "Player 2",
        turnLabel: "Turn: Player {n}",
        badgeBattle: "Battle Royale",
        badgeFinished: "Game finished",
        waitingOtherPlayer: "Waiting for the other player...",
        waitingBothPlayers: "Waiting for both players to join...",
        waitingStart: "Waiting to start...",
        waitingPlayersBattle: "Waiting for players to join the Battle Royale...",
        waitingStartBattle: "The Battle Royale is about to start...",
        statusCreatingRoom: "Creating room...",
        statusCreateSuccessDuel: "Room created! Wait for Player 2 to join.",
        statusCreateSuccessBattle: "Battle Royale room created! Share the code with your friends.",
        statusCreateError: "Error creating room.",
        statusJoinNeedCode: "Enter a room code.",
        statusJoinSearching: "Searching room...",
        statusJoinNotFound: "Room not found.",
        statusJoinFull: "Room is already full.",
        statusJoinFinished: "This game is already finished.",
        statusJoinSuccess: "You joined the room!",
        statusJoinError: "Error joining room.",
        roomClosed: "The room has been closed.",
        question: "Which country does this flag belong to?",
        questionBattle: "Guess the flag: one mistake and you're out!",
        msgTurnOtherPlayer: "It's the other player's turn.",
        msgCorrect: "Correct! üéâ",
        msgWrong: "Wrong! It was: ",
        msgCorrectBattle: "Correct! You stay alive. üéâ",
        msgWrongBattle: "Wrong! You are eliminated.",
        leftRoom: "You left the room.",
        battleStatus: "Players alive: {alive} / {total}",
        battleWinner: "Player {n} wins!",
        battleNoWinner: "No winner.",
        youWin: "You won the Battle Royale! üèÜ",
        youLose: "You have been eliminated from the Battle Royale.",
        youEliminated: "You have been eliminated. You can watch the rest of the game.",
        playerUnknown: "-",
        playerLabelBase: "Player"
      }
    };

    let currentLang = 'it';

    function t(key) {
      const table = translations[currentLang] || translations['en'];
      return (table && table[key]) || translations['en'][key] || key;
    }

    function applyTranslations() {
      document.getElementById('appTitle').textContent = t('title');
      document.getElementById('subtitleText').innerHTML = t('subtitle');
      document.getElementById('modeLabelTitle').textContent = t('modeTitle');
      document.getElementById('modeLabelDuel').textContent = t('modeDuel');
      document.getElementById('modeLabelBattle').textContent = t('modeBattle');
      document.getElementById('languageCardTitle').textContent = t('languageCardTitle');
      document.getElementById('createCardTitle').textContent = t('createCardTitle');
      document.getElementById('joinCardTitle').textContent = t('joinCardTitle');
      document.getElementById('createRoomBtn').textContent = t('createBtn');
      document.getElementById('joinRoomBtn').textContent = t('joinBtn');
      document.getElementById('joinCodeInput').placeholder = t('joinPlaceholder');
      document.getElementById('leaveBtn').textContent = t('leaveBtn');
      document.getElementById('playerTextLabel').textContent = t('playerText');
      document.getElementById('roomTextLabel').textContent = t('roomText');
      document.getElementById('scoreName1').textContent = t('scorePlayer1');
      document.getElementById('scoreName2').textContent = t('scorePlayer2');
    }

    // === DATI PAESI ===
    const countries = [
      { name: 'Afghanistan', code: 'af' },
      { name: '√Öland Islands', code: 'ax' },
      { name: 'Albania', code: 'al' },
      { name: 'Algeria', code: 'dz' },
      { name: 'American Samoa', code: 'as' },
      { name: 'Andorra', code: 'ad' },
      { name: 'Angola', code: 'ao' },
      { name: 'Anguilla', code: 'ai' },
      { name: 'Antarctica', code: 'aq' },
      { name: 'Antigua and Barbuda', code: 'ag' },
      { name: 'Argentina', code: 'ar' },
      { name: 'Armenia', code: 'am' },
      { name: 'Aruba', code: 'aw' },
      { name: 'Australia', code: 'au' },
      { name: 'Austria', code: 'at' },
      { name: 'Azerbaijan', code: 'az' },
      { name: 'Bahamas', code: 'bs' },
      { name: 'Bahrain', code: 'bh' },
      { name: 'Bangladesh', code: 'bd' },
      { name: 'Barbados', code: 'bb' },
      { name: 'Belarus', code: 'by' },
      { name: 'Belgium', code: 'be' },
      { name: 'Belize', code: 'bz' },
      { name: 'Benin', code: 'bj' },
      { name: 'Bermuda', code: 'bm' },
      { name: 'Bhutan', code: 'bt' },
      { name: 'Bolivia', code: 'bo' },
      { name: 'Bonaire, Sint Eustatius and Saba', code: 'bq' },
      { name: 'Bosnia and Herzegovina', code: 'ba' },
      { name: 'Botswana', code: 'bw' },
      { name: 'Bouvet Island', code: 'bv' },
      { name: 'Brazil', code: 'br' },
      { name: 'British Indian Ocean Territory', code: 'io' },
      { name: 'Brunei Darussalam', code: 'bn' },
      { name: 'Bulgaria', code: 'bg' },
      { name: 'Burkina Faso', code: 'bf' },
      { name: 'Burundi', code: 'bi' },
      { name: 'Cabo Verde', code: 'cv' },
      { name: 'Cambodia', code: 'kh' },
      { name: 'Cameroon', code: 'cm' },
      { name: 'Canada', code: 'ca' },
      { name: 'Cayman Islands', code: 'ky' },
      { name: 'Central African Republic', code: 'cf' },
      { name: 'Chad', code: 'td' },
      { name: 'Chile', code: 'cl' },
      { name: 'China', code: 'cn' },
      { name: 'Christmas Island', code: 'cx' },
      { name: 'Cocos (Keeling) Islands', code: 'cc' },
      { name: 'Colombia', code: 'co' },
      { name: 'Comoros', code: 'km' },
      { name: 'Congo', code: 'cg' },
      { name: 'Congo, Democratic Republic of the', code: 'cd' },
      { name: 'Cook Islands', code: 'ck' },
      { name: 'Costa Rica', code: 'cr' },
      { name: 'C√¥te d\'Ivoire', code: 'ci' },
      { name: 'Croatia', code: 'hr' },
      { name: 'Cuba', code: 'cu' },
      { name: 'Cura√ßao', code: 'cw' },
      { name: 'Cyprus', code: 'cy' },
      { name: 'Czechia', code: 'cz' },
      { name: 'Denmark', code: 'dk' },
      { name: 'Djibouti', code: 'dj' },
      { name: 'Dominica', code: 'dm' },
      { name: 'Dominican Republic', code: 'do' },
      { name: 'Ecuador', code: 'ec' },
      { name: 'Egypt', code: 'eg' },
      { name: 'El Salvador', code: 'sv' },
      { name: 'Equatorial Guinea', code: 'gq' },
      { name: 'Eritrea', code: 'er' },
      { name: 'Estonia', code: 'ee' },
      { name: 'Eswatini', code: 'sz' },
      { name: 'Ethiopia', code: 'et' },
      { name: 'Falkland Islands (Malvinas)', code: 'fk' },
      { name: 'Faroe Islands', code: 'fo' },
      { name: 'Fiji', code: 'fj' },
      { name: 'Finland', code: 'fi' },
      { name: 'France', code: 'fr' },
      { name: 'French Guiana', code: 'gf' },
      { name: 'French Polynesia', code: 'pf' },
      { name: 'French Southern Territories', code: 'tf' },
      { name: 'Gabon', code: 'ga' },
      { name: 'Gambia', code: 'gm' },
      { name: 'Georgia', code: 'ge' },
      { name: 'Germany', code: 'de' },
      { name: 'Ghana', code: 'gh' },
      { name: 'Gibraltar', code: 'gi' },
      { name: 'Greece', code: 'gr' },
      { name: 'Greenland', code: 'gl' },
      { name: 'Grenada', code: 'gd' },
      { name: 'Guadeloupe', code: 'gp' },
      { name: 'Guam', code: 'gu' },
      { name: 'Guatemala', code: 'gt' },
      { name: 'Guernsey', code: 'gg' },
      { name: 'Guinea', code: 'gn' },
      { name: 'Guinea-Bissau', code: 'gw' },
      { name: 'Guyana', code: 'gy' },
      { name: 'Haiti', code: 'ht' },
      { name: 'Heard Island and McDonald Islands', code: 'hm' },
      { name: 'Holy See', code: 'va' },
      { name: 'Honduras', code: 'hn' },
      { name: 'Hong Kong', code: 'hk' },
      { name: 'Hungary', code: 'hu' },
      { name: 'Iceland', code: 'is' },
      { name: 'India', code: 'in' },
      { name: 'Indonesia', code: 'id' },
      { name: 'Iran, Islamic Republic of', code: 'ir' },
      { name: 'Iraq', code: 'iq' },
      { name: 'Ireland', code: 'ie' },
      { name: 'Isle of Man', code: 'im' },
      { name: 'Israel', code: 'il' },
      { name: 'Italy', code: 'it' },
      { name: 'Jamaica', code: 'jm' },
      { name: 'Japan', code: 'jp' },
      { name: 'Jersey', code: 'je' },
      { name: 'Jordan', code: 'jo' },
      { name: 'Kazakhstan', code: 'kz' },
      { name: 'Kenya', code: 'ke' },
      { name: 'Kiribati', code: 'ki' },
      { name: 'Korea, Democratic People\'s Republic of', code: 'kp' },
      { name: 'Korea, Republic of', code: 'kr' },
      { name: 'Kuwait', code: 'kw' },
      { name: 'Kyrgyzstan', code: 'kg' },
      { name: 'Lao People\'s Democratic Republic', code: 'la' },
      { name: 'Latvia', code: 'lv' },
      { name: 'Lebanon', code: 'lb' },
      { name: 'Lesotho', code: 'ls' },
      { name: 'Liberia', code: 'lr' },
      { name: 'Libya', code: 'ly' },
      { name: 'Liechtenstein', code: 'li' },
      { name: 'Lithuania', code: 'lt' },
      { name: 'Luxembourg', code: 'lu' },
      { name: 'Macao', code: 'mo' },
      { name: 'Madagascar', code: 'mg' },
      { name: 'Malawi', code: 'mw' },
      { name: 'Malaysia', code: 'my' },
      { name: 'Maldives', code: 'mv' },
      { name: 'Mali', code: 'ml' },
      { name: 'Malta', code: 'mt' },
      { name: 'Marshall Islands', code: 'mh' },
      { name: 'Martinique', code: 'mq' },
      { name: 'Mauritania', code: 'mr' },
      { name: 'Mauritius', code: 'mu' },
      { name: 'Mayotte', code: 'yt' },
      { name: 'Mexico', code: 'mx' },
      { name: 'Micronesia, Federated States of', code: 'fm' },
      { name: 'Moldova, Republic of', code: 'md' },
      { name: 'Monaco', code: 'mc' },
      { name: 'Mongolia', code: 'mn' },
      { name: 'Montenegro', code: 'me' },
      { name: 'Montserrat', code: 'ms' },
      { name: 'Morocco', code: 'ma' },
      { name: 'Mozambique', code: 'mz' },
      { name: 'Myanmar', code: 'mm' },
      { name: 'Namibia', code: 'na' },
      { name: 'Nauru', code: 'nr' },
      { name: 'Nepal', code: 'np' },
      { name: 'Netherlands', code: 'nl' },
      { name: 'New Caledonia', code: 'nc' },
      { name: 'New Zealand', code: 'nz' },
      { name: 'Nicaragua', code: 'ni' },
      { name: 'Niger', code: 'ne' },
      { name: 'Nigeria', code: 'ng' },
      { name: 'Niue', code: 'nu' },
      { name: 'Norfolk Island', code: 'nf' },
      { name: 'North Macedonia', code: 'mk' },
      { name: 'Northern Mariana Islands', code: 'mp' },
      { name: 'Norway', code: 'no' },
      { name: 'Oman', code: 'om' },
      { name: 'Pakistan', code: 'pk' },
      { name: 'Palau', code: 'pw' },
      { name: 'Palestine, State of', code: 'ps' },
      { name: 'Panama', code: 'pa' },
      { name: 'Papua New Guinea', code: 'pg' },
      { name: 'Paraguay', code: 'py' },
      { name: 'Peru', code: 'pe' },
      { name: 'Philippines', code: 'ph' },
      { name: 'Pitcairn', code: 'pn' },
      { name: 'Poland', code: 'pl' },
      { name: 'Portugal', code: 'pt' },
      { name: 'Puerto Rico', code: 'pr' },
      { name: 'Qatar', code: 'qa' },
      { name: 'R√©union', code: 're' },
      { name: 'Romania', code: 'ro' },
      { name: 'Russian Federation', code: 'ru' },
      { name: 'Rwanda', code: 'rw' },
      { name: 'Saint Barth√©lemy', code: 'bl' },
      { name: 'Saint Helena, Ascension and Tristan da Cunha', code: 'sh' },
      { name: 'Saint Kitts and Nevis', code: 'kn' },
      { name: 'Saint Lucia', code: 'lc' },
      { name: 'Saint Martin (French part)', code: 'mf' },
      { name: 'Saint Pierre and Miquelon', code: 'pm' },
      { name: 'Saint Vincent and the Grenadines', code: 'vc' },
      { name: 'Samoa', code: 'ws' },
      { name: 'San Marino', code: 'sm' },
      { name: 'Sao Tome and Principe', code: 'st' },
      { name: 'Saudi Arabia', code: 'sa' },
      { name: 'Senegal', code: 'sn' },
      { name: 'Serbia', code: 'rs' },
      { name: 'Seychelles', code: 'sc' },
      { name: 'Sierra Leone', code: 'sl' },
      { name: 'Singapore', code: 'sg' },
      { name: 'Sint Maarten (Dutch part)', code: 'sx' },
      { name: 'Slovakia', code: 'sk' },
      { name: 'Slovenia', code: 'si' },
      { name: 'Solomon Islands', code: 'sb' },
      { name: 'Somalia', code: 'so' },
      { name: 'South Africa', code: 'za' },
      { name: 'South Georgia and the South Sandwich Islands', code: 'gs' },
      { name: 'South Sudan', code: 'ss' },
      { name: 'Spain', code: 'es' },
      { name: 'Sri Lanka', code: 'lk' },
      { name: 'Sudan', code: 'sd' },
      { name: 'Suriname', code: 'sr' },
      { name: 'Svalbard and Jan Mayen', code: 'sj' },
      { name: 'Sweden', code: 'se' },
      { name: 'Switzerland', code: 'ch' },
      { name: 'Syrian Arab Republic', code: 'sy' },
      { name: 'Taiwan, Province of China', code: 'tw' },
      { name: 'Tajikistan', code: 'tj' },
      { name: 'Tanzania, United Republic of', code: 'tz' },
      { name: 'Thailand', code: 'th' },
      { name: 'Timor-Leste', code: 'tl' },
      { name: 'Togo', code: 'tg' },
      { name: 'Tokelau', code: 'tk' },
      { name: 'Tonga', code: 'to' },
      { name: 'Trinidad and Tobago', code: 'tt' },
      { name: 'Tunisia', code: 'tn' },
      { name: 'T√ºrkiye', code: 'tr' },
      { name: 'Turkmenistan', code: 'tm' },
      { name: 'Turks and Caicos Islands', code: 'tc' },
      { name: 'Tuvalu', code: 'tv' },
      { name: 'Uganda', code: 'ug' },
      { name: 'Ukraine', code: 'ua' },
      { name: 'United Arab Emirates', code: 'ae' },
      { name: 'United Kingdom of Great Britain and Northern Ireland', code: 'gb' },
      { name: 'United States of America', code: 'us' },
      { name: 'United States Minor Outlying Islands', code: 'um' },
      { name: 'Uruguay', code: 'uy' },
      { name: 'Uzbekistan', code: 'uz' },
      { name: 'Vanuatu', code: 'vu' },
      { name: 'Venezuela, Bolivarian Republic of', code: 've' },
      { name: 'Viet Nam', code: 'vn' },
      { name: 'Virgin Islands, British', code: 'vg' },
      { name: 'Virgin Islands, U.S.', code: 'vi' },
      { name: 'Wallis and Futuna', code: 'wf' },
      { name: 'Western Sahara', code: 'eh' },
      { name: 'Yemen', code: 'ye' },
      { name: 'Zambia', code: 'zm' },
      { name: 'Zimbabwe', code: 'zw' }
    ];

    // === STATO LOCALE ===
    let playerNumber = null;   // per 1vs1 (1 o 2)
    let playerKey = null;      // per Battle Royale (id nel nodo players)
    let roomCode = null;
    let currentQuestionId = null;
    let answeringLocked = false;
    let roomRef = null;
    let gameMode = 'duel';     // 'duel' | 'battle'
    let lastKnownMeAlive = true;

    // === ELEMENTI DOM ===
    const createRoomBtn = document.getElementById('createRoomBtn');
    const roomCodeLabel = document.getElementById('roomCodeLabel');
    const createStatus = document.getElementById('createStatus');

    const joinCodeInput = document.getElementById('joinCodeInput');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const joinStatus = document.getElementById('joinStatus');

    const languageSelect = document.getElementById('languageSelect');
    const gameContainer = document.getElementById('gameContainer');
    const playerLabel = document.getElementById('playerLabel');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const turnBadge = document.getElementById('turnBadge');

    const scoresDuel = document.getElementById('scoresDuel');
    const battleStatusEl = document.getElementById('battleStatus');
    const scoreP1 = document.getElementById('scoreP1');
    const scoreP2 = document.getElementById('scoreP2');
    const score1El = document.getElementById('score1');
    const score2El = document.getElementById('score2');

    const questionTitle = document.getElementById('questionTitle');
    const flagImg = document.getElementById('flagImg');
    const optionsContainer = document.getElementById('optionsContainer');
    const gameMessage = document.getElementById('gameMessage');
    const leaveBtn = document.getElementById('leaveBtn');

    const modeInputs = document.querySelectorAll('input[name="mode"]');

    // === FUNZIONI DI SUPPORTO ===
    function randomRoomCode() {
      return Math.floor(1000 + Math.random() * 9000).toString();
    }

    function shuffleArray(array) {
      const arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      return arr;
    }

    function chooseRandomQuestion() {
      const randomIndex = Math.floor(Math.random() * countries.length);
      const correct = countries[randomIndex];
      const others = countries.filter(c => c !== correct);
      const shuffledOthers = shuffleArray(others).slice(0, 3);
      const options = shuffleArray([correct, ...shuffledOthers]);
      return {
        id: Date.now().toString(),
        correctCode: correct.code,
        correctName: correct.name,
        options: options.map(o => ({ name: o.name, code: o.code }))
      };
    }

    function getSelectedMode() {
      const checked = document.querySelector('input[name="mode"]:checked');
      return checked ? checked.value : 'duel';
    }

    // === LOGICA STANZA ===
    async function createRoom() {
      if (roomRef) return;
      gameMode = getSelectedMode();
      if (gameMode === 'duel') {
        await createRoomDuel();
      } else {
        await createRoomBattle();
      }
    }

    async function createRoomDuel() {
      try {
        createStatus.textContent = t('statusCreatingRoom');
        const code = randomRoomCode();
        roomCode = code;
        roomRef = db.ref('rooms/' + code);

        const initialQuestion = chooseRandomQuestion();

        await roomRef.set({
          code: code,
          mode: 'duel',
          createdAt: Date.now(),
          state: 'waiting',   // waiting | playing
          currentPlayer: 1,
          question: initialQuestion,
          scores: { p1: 0, p2: 0 },
          players: {
            p1: { joined: true },
            p2: { joined: false }
          }
        });

        playerNumber = 1;
        playerKey = null;
        setupRoomListener();
        createStatus.textContent = t('statusCreateSuccessDuel');
        roomCodeLabel.textContent = 'Code: ' + code;
        showGameUI();
      } catch (err) {
        console.error(err);
        createStatus.textContent = t('statusCreateError');
      }
    }

    async function createRoomBattle() {
      try {
        createStatus.textContent = t('statusCreatingRoom');
        const code = randomRoomCode();
        roomCode = code;
        roomRef = db.ref('rooms/' + code);

        const initialQuestion = chooseRandomQuestion();

        await roomRef.set({
          code: code,
          mode: 'battle',
          createdAt: Date.now(),
          state: 'playing',   // direttamente playing, altri entrano durante la partita
          question: initialQuestion,
          players: {}
        });

        // aggiungi il creatore come giocatore
        playerKey = roomRef.child('players').push().key;
        await roomRef.child('players/' + playerKey).set({
          joined: true,
          alive: true,
          score: 0
        });

        playerNumber = null;
        lastKnownMeAlive = true;

        setupRoomListener();
        createStatus.textContent = t('statusCreateSuccessBattle');
        roomCodeLabel.textContent = 'Code: ' + code;
        showGameUI();
      } catch (err) {
        console.error(err);
        createStatus.textContent = t('statusCreateError');
      }
    }

    async function joinRoom() {
      try {
        const code = joinCodeInput.value.trim();
        if (!code) {
          joinStatus.textContent = t('statusJoinNeedCode');
          return;
        }

        joinStatus.textContent = t('statusJoinSearching');
        const ref = db.ref('rooms/' + code);
        const snapshot = await ref.once('value');

        if (!snapshot.exists()) {
          joinStatus.textContent = t('statusJoinNotFound');
          return;
        }

        const data = snapshot.val();
        const mode = data.mode || 'duel';
        gameMode = mode;

        roomCode = code;
        roomRef = ref;

        if (mode === 'duel') {
          // stanza 1vs1 classica
          if (data.players && data.players.p2 && data.players.p2.joined) {
            joinStatus.textContent = t('statusJoinFull');
            roomRef = null;
            return;
          }

          playerNumber = 2;
          playerKey = null;
          await roomRef.child('players/p2').set({ joined: true });
          await roomRef.child('state').set('playing');
        } else {
          // Battle Royale
          if (data.state === 'finished') {
            joinStatus.textContent = t('statusJoinFinished');
            roomRef = null;
            return;
          }

          playerKey = roomRef.child('players').push().key;
          await roomRef.child('players/' + playerKey).set({
            joined: true,
            alive: true,
            score: 0
          });
          playerNumber = null;
          lastKnownMeAlive = true;
        }

        joinStatus.textContent = t('statusJoinSuccess');
        setupRoomListener();
        showGameUI();
      } catch (err) {
        console.error(err);
        joinStatus.textContent = t('statusJoinError');
      }
    }

    function showGameUI() {
      gameContainer.style.display = 'block';
      if (gameMode === 'duel' && playerNumber) {
        playerLabel.textContent = t('playerLabelBase') + ' ' + playerNumber;
      } else {
        playerLabel.textContent = t('playerUnknown');
      }
      roomCodeDisplay.textContent = roomCode || '';
    }

    function setupRoomListener() {
      if (!roomRef) return;

      roomRef.on('value', function (snapshot) {
        const data = snapshot.val();
        if (!data) {
          gameMessage.textContent = t('roomClosed');
          return;
        }

        gameMode = data.mode || 'duel';

        if (gameMode === 'duel') {
          updateDuelUI(data);
        } else {
          updateBattleUI(data);
        }
      });
    }

    function updateDuelUI(data) {
      scoresDuel.style.display = 'flex';
      battleStatusEl.style.display = 'none';

      const s1 = data.scores && typeof data.scores.p1 === 'number' ? data.scores.p1 : 0;
      const s2 = data.scores && typeof data.scores.p2 === 'number' ? data.scores.p2 : 0;
      score1El.textContent = s1;
      score2El.textContent = s2;

      const current = data.currentPlayer || 1;
      turnBadge.textContent = t('turnLabel').replace('{n}', current);

      if (current === 1) {
        scoreP1.classList.add('active');
        scoreP2.classList.remove('active');
      } else {
        scoreP2.classList.add('active');
        scoreP1.classList.remove('active');
      }

      const p1Joined = data.players && data.players.p1 && data.players.p1.joined;
      const p2Joined = data.players && data.players.p2 && data.players.p2.joined;

      if (playerNumber) {
        playerLabel.textContent = t('playerLabelBase') + ' ' + playerNumber;
      }

      if (!p1Joined || !p2Joined) {
        questionTitle.textContent = t('waitingBothPlayers');
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        return;
      }

      if (data.state !== 'playing') {
        questionTitle.textContent = t('waitingStart');
        return;
      }

      const q = data.question;
      if (!q) return;

      if (currentQuestionId !== q.id) {
        currentQuestionId = q.id;
        renderQuestion(q, data.currentPlayer);
      }
    }

    function updateBattleUI(data) {
      scoresDuel.style.display = 'none';
      battleStatusEl.style.display = 'block';

      turnBadge.textContent = data.state === 'finished' ? t('badgeFinished') : t('badgeBattle');

      const players = data.players || {};
      const ids = Object.keys(players);
      const total = ids.length;

      if (!playerKey) {
        playerLabel.textContent = t('playerUnknown');
      } else {
        const idx = ids.indexOf(playerKey);
        if (idx !== -1) {
          playerLabel.textContent = t('playerLabelBase') + ' ' + (idx + 1);
        } else {
          playerLabel.textContent = t('playerUnknown');
        }
      }

      const aliveIds = ids.filter(id => players[id].alive);
      const aliveCount = aliveIds.length;

      lastKnownMeAlive = playerKey && players[playerKey] ? !!players[playerKey].alive : false;

      let statusText = t('battleStatus')
        .replace('{alive}', aliveCount)
        .replace('{total}', total);

      if (data.state === 'finished') {
        if (data.winnerId) {
          const wIndex = ids.indexOf(data.winnerId);
          if (wIndex !== -1) {
            statusText += ' ' + t('battleWinner').replace('{n}', wIndex + 1);
          }
        } else {
          statusText += ' ' + t('battleNoWinner');
        }
      }

      battleStatusEl.textContent = statusText;

      if (total === 0) {
        questionTitle.textContent = t('waitingPlayersBattle');
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        return;
      }

      if (data.state !== 'playing') {
        if (data.state === 'finished') {
          if (playerKey && data.winnerId && data.winnerId === playerKey) {
            gameMessage.textContent = t('youWin');
          } else {
            gameMessage.textContent = t('youLose');
          }
        } else {
          questionTitle.textContent = t('waitingStartBattle');
        }
        return;
      }

      const q = data.question;
      if (!q) return;

      if (currentQuestionId !== q.id) {
        currentQuestionId = q.id;
        renderQuestion(q, null);
      }

      if (!lastKnownMeAlive && data.state === 'playing') {
        gameMessage.textContent = t('youEliminated');
        answeringLocked = true;
        Array.from(optionsContainer.querySelectorAll('.option-btn')).forEach(b => {
          b.disabled = true;
        });
      }
    }

    function renderQuestion(q, currentPlayer) {
      answeringLocked = false;
      gameMessage.textContent = '';

      questionTitle.textContent = gameMode === 'battle' ? t('questionBattle') : t('question');
      flagImg.src = 'https://flagcdn.com/w320/' + q.correctCode + '.png';
      flagImg.alt = 'Bandiera';

      optionsContainer.innerHTML = '';

      q.options.forEach(function (opt, index) {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.textContent = opt.name || ('Opzione ' + (index + 1));
        btn.dataset.correct = (opt.code === q.correctCode) ? 'true' : 'false';
        btn.addEventListener('click', function () {
          onAnswerClick(btn, q, currentPlayer);
        });
        optionsContainer.appendChild(btn);
      });

      if (gameMode === 'duel' && playerNumber !== currentPlayer) {
        gameMessage.textContent = t('msgTurnOtherPlayer');
      }
    }

    async function onAnswerClick(btn, q, currentPlayer) {
      if (answeringLocked) return;

      if (gameMode === 'duel' && playerNumber !== currentPlayer) {
        return;
      }

      if (gameMode === 'battle' && !lastKnownMeAlive) {
        return;
      }

      answeringLocked = true;
      const isCorrect = btn.dataset.correct === 'true';
      const optionButtons = Array.prototype.slice.call(
        optionsContainer.querySelectorAll('.option-btn')
      );

      optionButtons.forEach(function (b) {
        if (b.dataset.correct === 'true') {
          b.classList.add('correct');
        } else if (b === btn && !isCorrect) {
          b.classList.add('wrong');
        }
        b.disabled = true;
      });

      if (gameMode === 'duel') {
        if (isCorrect) {
          gameMessage.textContent = t('msgCorrect');
        } else {
          gameMessage.textContent = t('msgWrong') + q.correctName;
        }

        setTimeout(function () {
          roomRef.transaction(function (room) {
            if (!room) return room;

            if (room.question && room.question.id !== q.id) {
              return room;
            }

            room.scores = room.scores || { p1: 0, p2: 0 };

            if (isCorrect) {
              if (currentPlayer === 1) {
                room.scores.p1 = (room.scores.p1 || 0) + 1;
              } else {
                room.scores.p2 = (room.scores.p2 || 0) + 1;
              }
            }

            const newQ = chooseRandomQuestion();
            room.question = newQ;
            room.currentPlayer = currentPlayer === 1 ? 2 : 1;

            return room;
          });
        }, 900);
      } else {
        // Battle Royale
        if (isCorrect) {
          gameMessage.textContent = t('msgCorrectBattle');
        } else {
          gameMessage.textContent = t('msgWrongBattle');
        }

        setTimeout(function () {
          roomRef.transaction(function (room) {
            if (!room) return room;
            if (!room.question || room.question.id !== q.id) return room;
            if (!room.players) return room;
            const me = room.players[playerKey];
            if (!me) return room;

            // se gi√† ha risposto a questa domanda, non fare nulla
            if (me.answeredId === q.id) return room;

            if (!me.alive) return room;

            if (isCorrect) {
              me.score = (me.score || 0) + 1;
            } else {
              me.alive = false;
            }
            me.answeredId = q.id;

            const ids = Object.keys(room.players);
            const aliveIds = ids.filter(id => room.players[id].alive);
            const aliveCount = aliveIds.length;

            if (aliveCount <= 1) {
              room.state = 'finished';
              room.winnerId = aliveIds[0] || null;
              return room;
            }

            // controlla se tutti i vivi hanno risposto a questa domanda
            const allAliveAnswered = aliveIds.every(id => room.players[id].answeredId === q.id);
            if (allAliveAnswered) {
              room.question = chooseRandomQuestion();
            }

            return room;
          });
        }, 900);
      }
    }

    async function leaveRoom() {
      if (!roomRef) return;

      try {
        if (gameMode === 'duel' && playerNumber) {
          await roomRef.child('players/p' + playerNumber).set({ joined: false });

          if (playerNumber === 1) {
            // il creatore chiude la stanza
            await roomRef.remove();
          }
        } else if (gameMode === 'battle' && playerKey) {
          await roomRef.child('players/' + playerKey).update({ joined: false, alive: false });
        }

        gameMessage.textContent = t('leftRoom');
      } catch (e) {
        console.error(e);
      }

      roomRef.off();
      roomRef = null;
      roomCode = null;
      playerNumber = null;
      playerKey = null;
      currentQuestionId = null;
      lastKnownMeAlive = true;
      gameContainer.style.display = 'none';
      roomCodeLabel.textContent = '';
      createStatus.textContent = '';
    }

    // === EVENTI UI ===
    createRoomBtn.addEventListener('click', function () {
      createRoom();
    });

    joinRoomBtn.addEventListener('click', function () {
      if (roomRef) return;
      joinRoom();
    });

    leaveBtn.addEventListener('click', function () {
      leaveRoom();
    });

    languageSelect.addEventListener('change', function () {
      currentLang = languageSelect.value;
      applyTranslations();
    });

    // inizializza testi
    applyTranslations();
  </script>
</body>
</html>
