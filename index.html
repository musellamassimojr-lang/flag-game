
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Online Flag Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top left, #0ea5e9 0, #6366f1 35%, #0f172a 80%);
    }

    .app {
      background: radial-gradient(circle at top, #0f172a, #020617 65%);
      border-radius: 24px;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.65);
      padding: 22px 20px 20px;
      max-width: 960px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.4);
      position: relative;
      overflow: hidden;
      color: #e5e7eb;
    }

    .app::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 10% -10%, rgba(56,189,248,0.20), transparent 55%),
        radial-gradient(circle at 110% 110%, rgba(244,114,182,0.20), transparent 55%);
      opacity: 0.9;
      pointer-events: none;
    }

    .app > * {
      position: relative;
      z-index: 1;
    }

    h1 {
      margin: 0 0 4px 0;
      font-size: 1.7rem;
      letter-spacing: -0.02em;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: #f9fafb;
    }

    h1 span.logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 34px;
      height: 34px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #22c55e, #0ea5e9);
      color: white;
      font-size: 1.2rem;
      box-shadow: 0 6px 14px rgba(34,197,94,0.55);
      border: 2px solid rgba(15,23,42,0.9);
    }

    .subtitle {
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .subtitle strong {
      color: #e5e7eb;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .mode-row {
      display: inline-flex;
      background: linear-gradient(to right, rgba(15,23,42,0.85), rgba(15,23,42,0.95));
      border-radius: 999px;
      padding: 4px;
      align-items: center;
      gap: 4px;
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 4px 16px rgba(15,23,42,0.75);
    }

    .mode-row-label {
      font-size: 0.8rem;
      color: #e5e7eb;
      margin-right: 4px;
      padding-left: 6px;
      font-weight: 600;
    }

    .mode-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 11px;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      color: #cbd5f5;
      transition: background 0.15s, color 0.15s, transform 0.08s, box-shadow 0.08s;
      background: rgba(15,23,42,0.9);
      border: 1px solid transparent;
    }

    .mode-pill input {
      display: none;
    }

    .mode-pill.active {
      background: linear-gradient(to right, #0ea5e9, #6366f1);
      color: #f9fafb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(15,23,42,0.9);
      border-color: rgba(191,219,254,0.8);
    }

    .mode-pill span.badge-pill {
      font-size: 0.7rem;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.35);
    }

    .right-top {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .single-submodes {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .single-submodes-label {
      font-weight: 600;
      margin-right: 4px;
    }

    .single-pill {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      cursor: pointer;
      background: rgba(15,23,42,0.75);
      color: #e5e7eb;
      transition: background 0.15s, transform 0.08s, box-shadow 0.08s;
    }

    .single-pill.active {
      background: linear-gradient(to right, #22c55e, #22d3ee);
      color: #022c22;
      box-shadow: 0 4px 10px rgba(45,212,191,0.7);
      transform: translateY(-1px);
      border-color: transparent;
    }

    .top-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 12px;
      margin-bottom: 14px;
    }

    .card {
      border-radius: 18px;
      border: 1px solid rgba(30,64,175,0.6);
      padding: 10px 12px 9px;
      background: radial-gradient(circle at top, #020617, #020617 40%, #020617 100%);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 28px rgba(15,23,42,0.9);
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 0 0, rgba(56,189,248,0.25), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(45,212,191,0.2), transparent 55%);
      opacity: 0.9;
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      color: #e5e7eb;
    }

    .card-title small {
      font-size: 0.7rem;
      font-weight: 500;
      color: #9ca3af;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    input[type="text"] {
      flex: 1;
      padding: 7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.8);
      font-size: 0.9rem;
      background: rgba(15,23,42,0.9);
      color: #f9fafb;
      box-shadow: 0 3px 8px rgba(15,23,42,0.9);
    }

    input[type="text"]::placeholder {
      color: #6b7280;
    }

    .status {
      font-size: 0.8rem;
      color: #9ca3af;
      min-height: 1.2em;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 7px 13px;
      font-size: 0.9rem;
      cursor: pointer;
      background: linear-gradient(to right, #22c55e, #22d3ee);
      color: #022c22;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.09s ease, box-shadow 0.09s ease, background 0.15s, opacity 0.1s;
      font-weight: 600;
      box-shadow: 0 9px 18px rgba(34,197,94,0.55);
    }

    button span.btn-icon {
      font-size: 0.9rem;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 11px 24px rgba(34,197,94,0.75);
      background: linear-gradient(to right, #4ade80, #2dd4bf);
    }

    button.secondary {
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.8);
      color: #e5e7eb;
      box-shadow: 0 4px 10px rgba(15,23,42,0.9);
    }

    button.secondary:hover:not(:disabled) {
      background: rgba(30,64,175,0.9);
      box-shadow: 0 7px 16px rgba(30,64,175,0.9);
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .game-container {
      margin-top: 6px;
      border-radius: 20px;
      border: 1px solid rgba(37,99,235,0.9);
      padding: 14px;
      background: radial-gradient(circle at top, #020617, #020617 60%, #020617 100%);
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 40px rgba(15,23,42,1);
    }

    .game-container::before {
      content: "";
      position: absolute;
      inset: -50%;
      background:
        radial-gradient(circle at 10% 0, rgba(56,189,248,0.20), transparent 50%),
        radial-gradient(circle at 90% 100%, rgba(244,114,182,0.20), transparent 55%);
      opacity: 0.9;
      pointer-events: none;
    }

    .game-inner {
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.9rem;
      gap: 8px;
      flex-wrap: wrap;
      color: #e5e7eb;
    }

    .header-left {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }

    .header-left strong {
      font-weight: 600;
    }

    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      background: rgba(15,23,42,0.9);
      color: #bae6fd;
      font-weight: 600;
      border: 1px solid rgba(56,189,248,0.7);
      box-shadow: 0 3px 9px rgba(8,47,73,0.9);
    }

    .badge-timer {
      margin-left: 6px;
      padding-inline: 8px;
      border-radius: 999px;
      background: rgba(250,204,21,0.22);
      border: 1px solid rgba(234,179,8,0.9);
      font-size: 0.75rem;
      color: #facc15;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 3px 9px rgba(202,138,4,0.9);
    }

    .badge-timer span.dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #f97316;
      box-shadow: 0 0 0 3px rgba(249,115,22,0.3);
      animation: pulse 1.4s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      70% { transform: scale(1.3); opacity: 0.4; }
      100% { transform: scale(1); opacity: 1; }
    }

    .scores {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .score-card {
      flex: 1;
      border-radius: 14px;
      padding: 8px 10px;
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.95));
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      border: 1px solid rgba(148,163,184,0.9);
      box-shadow: 0 4px 10px rgba(15,23,42,1);
      color: #e5e7eb;
    }

    .score-card.active {
      background: radial-gradient(circle at top, rgba(56,189,248,0.16), rgba(15,23,42,0.95));
      border-color: #38bdf8;
      box-shadow:
        0 0 0 1px rgba(56,189,248,0.8),
        0 7px 18px rgba(37,99,235,0.9);
    }

    .score-name {
      font-weight: 600;
    }

    .score-note {
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .score-value {
      font-size: 1.1rem;
      font-weight: 700;
    }

    .life-hearts {
      font-size: 1.3rem;
      letter-spacing: 2px;
    }

    .battle-status {
      font-size: 0.85rem;
      margin-bottom: 6px;
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(15,23,42,0.8);
      border: 1px dashed rgba(148,163,184,0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      color: #e5e7eb;
      box-shadow: 0 4px 10px rgba(15,23,42,1);
    }

    .battle-status span.label {
      font-weight: 500;
      color: #e5e7eb;
    }

    .battle-status span.value {
      font-weight: 600;
      color: #bae6fd;
    }

    .battle-status small {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .battle-players-list {
      margin-bottom: 8px;
      max-height: 150px;
      overflow-y: auto;
      border-radius: 12px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(55,65,81,0.9);
      padding: 6px 8px;
      font-size: 0.8rem;
      box-shadow: 0 4px 12px rgba(15,23,42,1);
    }

    .battle-player {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 3px 4px;
      border-radius: 8px;
      margin-bottom: 2px;
    }

    .battle-player.me {
      background: rgba(56,189,248,0.12);
      border: 1px solid rgba(56,189,248,0.7);
    }

    .battle-player.alive {
      color: #bbf7d0;
    }

    .battle-player.dead {
      color: #6b7280;
      opacity: 0.85;
    }

    .battle-player-name {
      font-weight: 600;
      max-width: 120px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .battle-player-score {
      font-weight: 600;
      min-width: 40px;
      text-align: right;
    }

    .battle-player-status {
      font-size: 0.7rem;
      margin-left: 6px;
    }

    .flag-card {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.9);
      padding: 10px 10px 12px;
      background: radial-gradient(circle at 10% 0, rgba(8,47,73,0.9), #020617 60%);
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 8px;
      box-shadow: 0 9px 24px rgba(15,23,42,1);
      position: relative;
      overflow: hidden;
    }

    .flag-card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 0 0, rgba(56,189,248,0.26), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(244,114,182,0.26), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .flag-card h2 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      font-weight: 700;
      color: #f9fafb;
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .flag-wrapper {
      position: relative;
      width: 100%;
      max-width: 280px;
      aspect-ratio: 3 / 2;
      border-radius: 16px;
      overflow: hidden;
      border: 2px solid rgba(148,163,184,0.9);
      background: radial-gradient(circle at top, #0f172a, #020617);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
      box-shadow: 0 8px 18px rgba(15,23,42,1);
      z-index: 1;
    }

    .flag-wrapper::before {
      content: "";
      position: absolute;
      inset: -20%;
      background-image:
        radial-gradient(circle at 10% 10%, rgba(248,250,252,0.06) 0, transparent 55%),
        radial-gradient(circle at 80% 90%, rgba(248,250,252,0.06) 0, transparent 55%);
      pointer-events: none;
    }

    .flag-wrapper img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
      position: relative;
      z-index: 1;
    }

    .options {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 6px;
      width: 100%;
      position: relative;
      z-index: 1;
    }

    .option-btn {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.9);
      background: linear-gradient(to bottom, rgba(15,23,42,0.95), rgba(15,23,42,1));
      cursor: pointer;
      font-size: 0.9rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s, border 0.15s;
      text-align: center;
      color: #e5e7eb;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(15,23,42,1);
    }

    .option-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 7px 16px rgba(0,0,0,0.7);
      background: linear-gradient(to bottom, rgba(30,64,175,1), rgba(15,23,42,1));
      border-color: rgba(129,140,248,0.9);
    }

    .option-btn.correct {
      background: #16a34a;
      border-color: #bbf7d0;
      box-shadow: 0 0 0 1px rgba(187,247,208,0.9), 0 7px 16px rgba(22,163,74,0.95);
      color: #f0fdf4;
    }

    .option-btn.wrong {
      background: #b91c1c;
      border-color: #fecaca;
      box-shadow: 0 0 0 1px rgba(254,202,202,0.9), 0 7px 16px rgba(185,28,28,0.95);
      color: #fef2f2;
    }

    .option-btn:disabled {
      cursor: default;
      opacity: 0.85;
      transform: none;
    }

    .leaderboard-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.9);
      padding: 8px 10px;
      background: rgba(15,23,42,0.95);
      margin-bottom: 6px;
      box-shadow: 0 4px 12px rgba(15,23,42,1);
      font-size: 0.85rem;
      color: #e5e7eb;
    }

    .leaderboard-card h3 {
      margin: 0 0 4px 0;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #e5e7eb;
    }

    .leaderboard-card small {
      color: #9ca3af;
    }

    .leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 4px 0 0 0;
    }

    .leaderboard-list li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
      font-size: 0.8rem;
    }

    .leaderboard-list li span.name {
      max-width: 120px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .game-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: #9ca3af;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .message {
      min-height: 1.2em;
    }

    @media (max-width: 640px) {
      .app {
        border-radius: 0;
        min-height: 100vh;
      }
      .options {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>
      <span class="logo">üåç</span>
      <span>Online Flag Quiz</span>
    </h1>
    <div class="subtitle">
      Play <strong>1 vs 1 online</strong>, <strong>Battle Royale</strong> or
      <strong>Single player</strong> (3 lives &amp; Time Attack).
    </div>

    <div class="top-bar">
      <div class="mode-row">
        <span class="mode-row-label">Mode:</span>
        <label class="mode-pill active" data-mode="duel">
          <input type="radio" name="mode" value="duel" checked />
          <span>1 vs 1</span>
          <span class="badge-pill">vs</span>
        </label>
        <label class="mode-pill" data-mode="battle">
          <input type="radio" name="mode" value="battle" />
          <span>Private Battle Royale</span>
          <span class="badge-pill">üî•</span>
        </label>
        <label class="mode-pill" data-mode="single">
          <input type="radio" name="mode" value="single" />
          <span>Single player</span>
          <span class="badge-pill">üéÆ</span>
        </label>
      </div>

      <div class="right-top">
        <span>Set your player name for online modes and Time Attack leaderboard.</span>
      </div>
    </div>

    <div class="single-submodes">
      <span class="single-submodes-label">Single player:</span>
      <button type="button" class="single-pill active" data-single-mode="lives3">3 Lives</button>
      <button type="button" class="single-pill" data-single-mode="timeAttack">Time Attack (1:30)</button>
    </div>

    <div class="top-row">
      <div class="card">
        <div class="card-inner">
          <div class="card-title">
            <span>1. Create room / game</span>
            <small>Share the code (online)</small>
          </div>
          <div class="row">
            <button id="createRoomBtn">
              <span class="btn-icon">‚ûï</span>
              <span>Create game</span>
            </button>
            <span id="roomCodeLabel" style="font-size:0.9rem; font-weight:600;"></span>
          </div>
          <div class="status" id="createStatus"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="card-title">
            <span>2. Join room</span>
          </div>
          <div class="row">
            <input type="text" id="joinCodeInput" placeholder="Room code (e.g. 4821)" />
            <button id="joinRoomBtn" class="secondary">
              <span class="btn-icon">‚û°Ô∏è</span>
              <span>Join</span>
            </button>
          </div>
          <div class="status" id="joinStatus"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="card-title">
            <span>Public Battle Royale</span>
            <small>Auto matchmaking</small>
          </div>
          <div class="row">
            <button id="publicBattleBtn" class="secondary">
              <span class="btn-icon">üåê</span>
              <span>Play now</span>
            </button>
          </div>
          <div class="status" id="publicBattleStatus"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="card-title">
            <span>Player name</span>
            <small>Visible online &amp; in leaderboard</small>
          </div>
          <div class="row">
            <input type="text" id="playerNameInput" placeholder="Your name (optional)" />
          </div>
        </div>
      </div>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
      <div class="game-inner">
        <div class="header">
          <div class="header-left">
            <span>Player:</span>
            <strong id="playerLabel"></strong>
            <span>‚Ä¢</span>
            <span>Room:</span>
            <strong id="roomCodeDisplay"></strong>
          </div>
          <div>
            <span class="badge" id="turnBadge">Turn: -</span>
            <span class="badge-timer" id="timerBadge" style="display:none;">
              <span class="dot"></span>
              <span id="timerText">90s</span>
            </span>
          </div>
        </div>

        <div class="scores" id="scoresDuel">
          <div class="score-card" id="scoreP1">
            <div>
              <span class="score-name">Player 1</span><br/>
              <span class="score-note" id="scoreNote1">Room creator</span>
            </div>
            <span class="score-value" id="score1">0</span>
          </div>
          <div class="score-card" id="scoreP2">
            <div>
              <span class="score-name">Player 2</span><br/>
              <span class="score-note" id="scoreNote2">Challenger</span>
            </div>
            <span class="score-value" id="score2">0</span>
          </div>
        </div>

        <!-- SINGLE PLAYER SCORE -->
        <div class="scores" id="scoresSingle" style="display:none;">
          <div class="score-card">
            <div>
              <span class="score-name" id="singleScoreTitle">Score</span><br/>
              <span class="score-note" id="singleScoreNote">Single player</span>
            </div>
            <span class="score-value" id="singleScoreValue">0</span>
          </div>
          <div class="score-card" id="singleRightCard">
            <div>
              <span class="score-name" id="singleLivesTitle">Lives</span><br/>
              <span class="score-note" id="singleLivesNote">Max 3 lives</span>
            </div>
            <span class="score-value life-hearts" id="singleLivesValue">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
          </div>
        </div>

        <div class="battle-status" id="battleStatus" style="display:none;">
          <div>
            <span class="label">Alive players:</span>
            <span class="value" id="battlePlayersValue">0 / 0</span>
          </div>
          <div>
            <small id="battleExtra"></small>
          </div>
        </div>

        <div class="battle-players-list" id="battlePlayersList" style="display:none;"></div>

        <div class="flag-card">
          <h2 id="questionTitle">Waiting for the other player...</h2>
          <div class="flag-wrapper">
            <img id="flagImg" src="" alt="Flag" />
          </div>
          <div class="options" id="optionsContainer"></div>
        </div>

        <div class="leaderboard-card" id="timeAttackLeaderboard" style="display:none;">
          <h3>
            <span>Time Attack ‚Äì Today‚Äôs Top 5</span>
            <small id="leaderboardDate"></small>
          </h3>
          <ul class="leaderboard-list" id="leaderboardList"></ul>
        </div>

        <div class="game-footer">
          <div class="message" id="gameMessage"></div>
          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button id="restartTimeAttackBtn" class="secondary" style="display:none;">
              <span class="btn-icon">üîÅ</span>
              <span>Restart Time Attack</span>
            </button>
            <button id="leaveBtn" class="secondary">
              <span class="btn-icon">‚èè</span>
              <span>Leave game</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
    // === Firebase ===
    const firebaseConfig = {
      apiKey: "AIzaSyCS2yJAOJvjzgRjwfy8KkWLFN_Yc9nJRpE",
      authDomain: "flags-game-1-vs-1.firebaseapp.com",
      databaseURL: "https://flags-game-1-vs-1-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "flags-game-1-vs-1",
      storageBucket: "flags-game-1-vs-1.firebasestorage.app",
      messagingSenderId: "35708843440",
      appId: "1:35708843440:web:08c2953678946dbc8f5275",
      measurementId: "G-21MV1D94MD"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // === Country data (English names) ===
    const countries = [
  { name: 'Afghanistan', code: 'af' },
  { name: '√Öland Islands', code: 'ax' },
  { name: 'Albania', code: 'al' },
  { name: 'Algeria', code: 'dz' },
  { name: 'American Samoa', code: 'as' },
  { name: 'Andorra', code: 'ad' },
  { name: 'Angola', code: 'ao' },
  { name: 'Anguilla', code: 'ai' },
  { name: 'Antarctica', code: 'aq' },
  { name: 'Antigua and Barbuda', code: 'ag' },
  { name: 'Argentina', code: 'ar' },
  { name: 'Armenia', code: 'am' },
  { name: 'Aruba', code: 'aw' },
  { name: 'Australia', code: 'au' },
  { name: 'Austria', code: 'at' },
  { name: 'Azerbaijan', code: 'az' },
  { name: 'Bahamas', code: 'bs' },
  { name: 'Bahrain', code: 'bh' },
  { name: 'Bangladesh', code: 'bd' },
  { name: 'Barbados', code: 'bb' },
  { name: 'Belarus', code: 'by' },
  { name: 'Belgium', code: 'be' },
  { name: 'Belize', code: 'bz' },
  { name: 'Benin', code: 'bj' },
  { name: 'Bermuda', code: 'bm' },
  { name: 'Bhutan', code: 'bt' },
  { name: 'Bolivia', code: 'bo' },
  { name: 'Bonaire, Sint Eustatius and Saba', code: 'bq' },
  { name: 'Bosnia and Herzegovina', code: 'ba' },
  { name: 'Botswana', code: 'bw' },
  { name: 'Bouvet Island', code: 'bv' },
  { name: 'Brazil', code: 'br' },
  { name: 'British Indian Ocean Territory', code: 'io' },
  { name: 'Brunei Darussalam', code: 'bn' },
  { name: 'Bulgaria', code: 'bg' },
  { name: 'Burkina Faso', code: 'bf' },
  { name: 'Burundi', code: 'bi' },
  { name: 'Cabo Verde', code: 'cv' },
  { name: 'Cambodia', code: 'kh' },
  { name: 'Cameroon', code: 'cm' },
  { name: 'Canada', code: 'ca' },
  { name: 'Cayman Islands', code: 'ky' },
  { name: 'Central African Republic', code: 'cf' },
  { name: 'Chad', code: 'td' },
  { name: 'Chile', code: 'cl' },
  { name: 'China', code: 'cn' },
  { name: 'Christmas Island', code: 'cx' },
  { name: 'Cocos (Keeling) Islands', code: 'cc' },
  { name: 'Colombia', code: 'co' },
  { name: 'Comoros', code: 'km' },
  { name: 'Congo', code: 'cg' },
  { name: 'Congo, Democratic Republic of the', code: 'cd' },
  { name: 'Cook Islands', code: 'ck' },
  { name: 'Costa Rica', code: 'cr' },
  { name: "C√¥te d'Ivoire", code: 'ci' },
  { name: 'Croatia', code: 'hr' },
  { name: 'Cuba', code: 'cu' },
  { name: 'Cura√ßao', code: 'cw' },
  { name: 'Cyprus', code: 'cy' },
  { name: 'Czechia', code: 'cz' },
  { name: 'Denmark', code: 'dk' },
  { name: 'Djibouti', code: 'dj' },
  { name: 'Dominica', code: 'dm' },
  { name: 'Dominican Republic', code: 'do' },
  { name: 'Ecuador', code: 'ec' },
  { name: 'Egypt', code: 'eg' },
  { name: 'El Salvador', code: 'sv' },
  { name: 'Equatorial Guinea', code: 'gq' },
  { name: 'Eritrea', code: 'er' },
  { name: 'Estonia', code: 'ee' },
  { name: 'Eswatini', code: 'sz' },
  { name: 'Ethiopia', code: 'et' },
  { name: 'Falkland Islands (Malvinas)', code: 'fk' },
  { name: 'Faroe Islands', code: 'fo' },
  { name: 'Fiji', code: 'fj' },
  { name: 'Finland', code: 'fi' },
  { name: 'France', code: 'fr' },
  { name: 'French Guiana', code: 'gf' },
  { name: 'French Polynesia', code: 'pf' },
  { name: 'French Southern Territories', code: 'tf' },
  { name: 'Gabon', code: 'ga' },
  { name: 'Gambia', code: 'gm' },
  { name: 'Georgia', code: 'ge' },
  { name: 'Germany', code: 'de' },
  { name: 'Ghana', code: 'gh' },
  { name: 'Gibraltar', code: 'gi' },
  { name: 'Greece', code: 'gr' },
  { name: 'Greenland', code: 'gl' },
  { name: 'Grenada', code: 'gd' },
  { name: 'Guadeloupe', code: 'gp' },
  { name: 'Guam', code: 'gu' },
  { name: 'Guatemala', code: 'gt' },
  { name: 'Guernsey', code: 'gg' },
  { name: 'Guinea', code: 'gn' },
  { name: 'Guinea-Bissau', code: 'gw' },
  { name: 'Guyana', code: 'gy' },
  { name: 'Haiti', code: 'ht' },
  { name: 'Heard Island and McDonald Islands', code: 'hm' },
  { name: 'Holy See', code: 'va' },
  { name: 'Honduras', code: 'hn' },
  { name: 'Hong Kong', code: 'hk' },
  { name: 'Hungary', code: 'hu' },
  { name: 'Iceland', code: 'is' },
  { name: 'India', code: 'in' },
  { name: 'Indonesia', code: 'id' },
  { name: 'Iran, Islamic Republic of', code: 'ir' },
  { name: 'Iraq', code: 'iq' },
  { name: 'Ireland', code: 'ie' },
  { name: 'Isle of Man', code: 'im' },
  { name: 'Israel', code: 'il' },
  { name: 'Italy', code: 'it' },
  { name: 'Jamaica', code: 'jm' },
  { name: 'Japan', code: 'jp' },
  { name: 'Jersey', code: 'je' },
  { name: 'Jordan', code: 'jo' },
  { name: 'Kazakhstan', code: 'kz' },
  { name: 'Kenya', code: 'ke' },
  { name: 'Kiribati', code: 'ki' },
  { name: "Korea, Democratic People's Republic of", code: 'kp' },
  { name: 'Korea, Republic of', code: 'kr' },
  { name: 'Kuwait', code: 'kw' },
  { name: 'Kyrgyzstan', code: 'kg' },
  { name: "Lao People's Democratic Republic", code: 'la' },
  { name: 'Latvia', code: 'lv' },
  { name: 'Lebanon', code: 'lb' },
  { name: 'Lesotho', code: 'ls' },
  { name: 'Liberia', code: 'lr' },
  { name: 'Libya', code: 'ly' },
  { name: 'Liechtenstein', code: 'li' },
  { name: 'Lithuania', code: 'lt' },
  { name: 'Luxembourg', code: 'lu' },
  { name: 'Macao', code: 'mo' },
  { name: 'Madagascar', code: 'mg' },
  { name: 'Malawi', code: 'mw' },
  { name: 'Malaysia', code: 'my' },
  { name: 'Maldives', code: 'mv' },
  { name: 'Mali', code: 'ml' },
  { name: 'Malta', code: 'mt' },
  { name: 'Marshall Islands', code: 'mh' },
  { name: 'Martinique', code: 'mq' },
  { name: 'Mauritania', code: 'mr' },
  { name: 'Mauritius', code: 'mu' },
  { name: 'Mayotte', code: 'yt' },
  { name: 'Mexico', code: 'mx' },
  { name: 'Micronesia, Federated States of', code: 'fm' },
  { name: 'Moldova, Republic of', code: 'md' },
  { name: 'Monaco', code: 'mc' },
  { name: 'Mongolia', code: 'mn' },
  { name: 'Montenegro', code: 'me' },
  { name: 'Montserrat', code: 'ms' },
  { name: 'Morocco', code: 'ma' },
  { name: 'Mozambique', code: 'mz' },
  { name: 'Myanmar', code: 'mm' },
  { name: 'Namibia', code: 'na' },
  { name: 'Nauru', code: 'nr' },
  { name: 'Nepal', code: 'np' },
  { name: 'Netherlands', code: 'nl' },
  { name: 'New Caledonia', code: 'nc' },
  { name: 'New Zealand', code: 'nz' },
  { name: 'Nicaragua', code: 'ni' },
  { name: 'Niger', code: 'ne' },
  { name: 'Nigeria', code: 'ng' },
  { name: 'Niue', code: 'nu' },
  { name: 'Norfolk Island', code: 'nf' },
  { name: 'North Macedonia', code: 'mk' },
  { name: 'Northern Mariana Islands', code: 'mp' },
  { name: 'Norway', code: 'no' },
  { name: 'Oman', code: 'om' },
  { name: 'Pakistan', code: 'pk' },
  { name: 'Palau', code: 'pw' },
  { name: 'Palestine, State of', code: 'ps' },
  { name: 'Panama', code: 'pa' },
  { name: 'Papua New Guinea', code: 'pg' },
  { name: 'Paraguay', code: 'py' },
  { name: 'Peru', code: 'pe' },
  { name: 'Philippines', code: 'ph' },
  { name: 'Pitcairn', code: 'pn' },
  { name: 'Poland', code: 'pl' },
  { name: 'Portugal', code: 'pt' },
  { name: 'Puerto Rico', code: 'pr' },
  { name: 'Qatar', code: 'qa' },
  { name: 'R√©union', code: 're' },
  { name: 'Romania', code: 'ro' },
  { name: 'Russian Federation', code: 'ru' },
  { name: 'Rwanda', code: 'rw' },
  { name: 'Saint Barth√©lemy', code: 'bl' },
  { name: 'Saint Helena, Ascension and Tristan da Cunha', code: 'sh' },
  { name: 'Saint Kitts and Nevis', code: 'kn' },
  { name: 'Saint Lucia', code: 'lc' },
  { name: 'Saint Martin (French part)', code: 'mf' },
  { name: 'Saint Pierre and Miquelon', code: 'pm' },
  { name: 'Saint Vincent and the Grenadines', code: 'vc' },
  { name: 'Samoa', code: 'ws' },
  { name: 'San Marino', code: 'sm' },
  { name: 'Sao Tome and Principe', code: 'st' },
  { name: 'Saudi Arabia', code: 'sa' },
  { name: 'Senegal', code: 'sn' },
  { name: 'Serbia', code: 'rs' },
  { name: 'Seychelles', code: 'sc' },
  { name: 'Sierra Leone', code: 'sl' },
  { name: 'Singapore', code: 'sg' },
  { name: 'Sint Maarten (Dutch part)', code: 'sx' },
  { name: 'Slovakia', code: 'sk' },
  { name: 'Slovenia', code: 'si' },
  { name: 'Solomon Islands', code: 'sb' },
  { name: 'Somalia', code: 'so' },
  { name: 'South Africa', code: 'za' },
  { name: 'South Georgia and the South Sandwich Islands', code: 'gs' },
  { name: 'South Sudan', code: 'ss' },
  { name: 'Spain', code: 'es' },
  { name: 'Sri Lanka', code: 'lk' },
  { name: 'Sudan', code: 'sd' },
  { name: 'Suriname', code: 'sr' },
  { name: 'Svalbard and Jan Mayen', code: 'sj' },
  { name: 'Sweden', code: 'se' },
  { name: 'Switzerland', code: 'ch' },
  { name: 'Syrian Arab Republic', code: 'sy' },
  { name: 'Taiwan, Province of China', code: 'tw' },
  { name: 'Tajikistan', code: 'tj' },
  { name: 'Tanzania, United Republic of', code: 'tz' },
  { name: 'Thailand', code: 'th' },
  { name: 'Timor-Leste', code: 'tl' },
  { name: 'Togo', code: 'tg' },
  { name: 'Tokelau', code: 'tk' },
  { name: 'Tonga', code: 'to' },
  { name: 'Trinidad and Tobago', code: 'tt' },
  { name: 'Tunisia', code: 'tn' },
  { name: 'T√ºrkiye', code: 'tr' },
  { name: 'Turkmenistan', code: 'tm' },
  { name: 'Turks and Caicos Islands', code: 'tc' },
  { name: 'Tuvalu', code: 'tv' },
  { name: 'Uganda', code: 'ug' },
  { name: 'Ukraine', code: 'ua' },
  { name: 'United Arab Emirates', code: 'ae' },
  { name: 'United Kingdom of Great Britain and Northern Ireland', code: 'gb' },
  { name: 'United States of America', code: 'us' },
  { name: 'United States Minor Outlying Islands', code: 'um' },
  { name: 'Uruguay', code: 'uy' },
  { name: 'Uzbekistan', code: 'uz' },
  { name: 'Vanuatu', code: 'vu' },
  { name: 'Venezuela, Bolivarian Republic of', code: 've' },
  { name: 'Viet Nam', code: 'vn' },
  { name: 'Virgin Islands, British', code: 'vg' },
  { name: 'Virgin Islands, U.S.', code: 'vi' },
  { name: 'Wallis and Futuna', code: 'wf' },
  { name: 'Western Sahara', code: 'eh' },
  { name: 'Yemen', code: 'ye' },
  { name: 'Zambia', code: 'zm' },
  { name: 'Zimbabwe', code: 'zw' }
];


    // === Local state ===
    let playerNumber = null;   // for 1vs1 (1 or 2)
    let playerKey = null;      // for Battle Royale
    let roomCode = null;
    let currentQuestionId = null;
    let answeringLocked = false;
    let roomRef = null;
    let gameMode = 'duel';     // 'duel' | 'battle' | 'battlePublic' | 'single'
    let lastKnownMeAlive = true;

    // Single player
    let singleMode = 'lives3'; // 'lives3' | 'timeAttack'
    let singleLives = 3;
    let singleScore = 0;
    let singleQuestion = null;
    let singlePlayerName = '';

    // Time Attack
    const TIME_ATTACK_MS = 90 * 1000;
    let timeAttackEndTime = null;
    let timeAttackInterval = null;

    // Battle Royale
    const BATTLE_TIME_LIMIT_MS = 10000;
    const LOBBY_COUNTDOWN_MS = 15000;
    const PUBLIC_MIN_PLAYERS = 10;
    const PUBLIC_MAX_PLAYERS = 100; // requested change

    let currentLobbyStartTime = null;
    let currentQuestionStartTime = null;
    let timerMode = null; // 'lobby' | 'question' | null
    let sharedTimerInterval = null;

    // Avoid repeated flags
    const MAX_RECENT_CODES = 15;
    let recentQuestionCodes = [];

    // === DOM elements ===
    const createRoomBtn = document.getElementById('createRoomBtn');
    const roomCodeLabel = document.getElementById('roomCodeLabel');
    const createStatus = document.getElementById('createStatus');

    const joinCodeInput = document.getElementById('joinCodeInput');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const joinStatus = document.getElementById('joinStatus');

    const publicBattleBtn = document.getElementById('publicBattleBtn');
    const publicBattleStatus = document.getElementById('publicBattleStatus');

    const playerNameInput = document.getElementById('playerNameInput');

    const gameContainer = document.getElementById('gameContainer');
    const playerLabel = document.getElementById('playerLabel');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const turnBadge = document.getElementById('turnBadge');
    const timerBadge = document.getElementById('timerBadge');
    const timerText = document.getElementById('timerText');

    const scoresDuel = document.getElementById('scoresDuel');
    const scoresSingle = document.getElementById('scoresSingle');
    const singleScoreValue = document.getElementById('singleScoreValue');
    const singleLivesValue = document.getElementById('singleLivesValue');
    const singleLivesTitle = document.getElementById('singleLivesTitle');
    const singleLivesNote = document.getElementById('singleLivesNote');
    const singleRightCard = document.getElementById('singleRightCard');

    const battleStatusEl = document.getElementById('battleStatus');
    const battlePlayersValue = document.getElementById('battlePlayersValue');
    const battleExtra = document.getElementById('battleExtra');
    const battlePlayersList = document.getElementById('battlePlayersList');
    const scoreP1 = document.getElementById('scoreP1');
    const scoreP2 = document.getElementById('scoreP2');
    const score1El = document.getElementById('score1');
    const score2El = document.getElementById('score2');

    const questionTitle = document.getElementById('questionTitle');
    const flagImg = document.getElementById('flagImg');
    const optionsContainer = document.getElementById('optionsContainer');
    const gameMessage = document.getElementById('gameMessage');
    const leaveBtn = document.getElementById('leaveBtn');
    const restartTimeAttackBtn = document.getElementById('restartTimeAttackBtn');

    const timeAttackLeaderboard = document.getElementById('timeAttackLeaderboard');
    const leaderboardDate = document.getElementById('leaderboardDate');
    const leaderboardList = document.getElementById('leaderboardList');

    const modePills = document.querySelectorAll('.mode-pill');
    const singlePills = document.querySelectorAll('.single-pill');

    // === Helpers ===
    function randomRoomCode() {
      return Math.floor(1000 + Math.random() * 9000).toString();
    }

    function shuffleArray(array) {
      const arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function chooseRandomQuestion() {
      let candidate;
      for (let tries = 0; tries < 30; tries++) {
        const randomIndex = Math.floor(Math.random() * countries.length);
        candidate = countries[randomIndex];
        if (!recentQuestionCodes.includes(candidate.code)) break;
      }
      if (!candidate) candidate = countries[Math.floor(Math.random() * countries.length)];

      recentQuestionCodes.push(candidate.code);
      if (recentQuestionCodes.length > MAX_RECENT_CODES) {
        recentQuestionCodes.shift();
      }

      const others = countries.filter(c => c !== candidate);
      const shuffledOthers = shuffleArray(others).slice(0, 3);
      const options = shuffleArray([candidate, ...shuffledOthers]);
      const now = Date.now();
      currentQuestionStartTime = now;
      return {
        id: now.toString(),
        correctCode: candidate.code,
        correctName: candidate.name,
        options: options.map(o => ({ name: o.name, code: o.code })),
        startTime: now
      };
    }

    function getSelectedMode() {
      const checked = document.querySelector('input[name="mode"]:checked');
      return checked ? checked.value : 'duel';
    }

    function getPlayerNameFallback() {
      return 'Player ' + (Math.floor(Math.random() * 900) + 100);
    }

    function clearSharedTimer() {
      if (sharedTimerInterval) {
        clearInterval(sharedTimerInterval);
        sharedTimerInterval = null;
      }
      timerMode = null;
      if (gameMode !== 'single' || singleMode !== 'timeAttack') {
        timerBadge.style.display = 'none';
      }
    }

    function stopTimeAttackTimer() {
      if (timeAttackInterval) {
        clearInterval(timeAttackInterval);
        timeAttackInterval = null;
      }
      timeAttackEndTime = null;
      if (gameMode === 'single' && singleMode === 'timeAttack') {
        timerBadge.style.display = 'none';
      }
    }

    function startLobbyTimer(lobbyStartTime) {
      clearSharedTimer();
      currentLobbyStartTime = lobbyStartTime || Date.now();
      timerMode = 'lobby';
      timerBadge.style.display = 'inline-flex';

      function tick() {
        if (timerMode !== 'lobby' || !roomRef) {
          clearSharedTimer();
          return;
        }
        const now = Date.now();
        const remaining = Math.max(0, LOBBY_COUNTDOWN_MS - (now - currentLobbyStartTime));
        const seconds = Math.ceil(remaining / 1000);
        timerText.textContent = 'Lobby: ' + seconds + 's';

        if (remaining <= 0) {
          clearSharedTimer();
          roomRef.transaction(function (room) {
            if (!room) return room;
            if (room.state !== 'lobby') return room;
            if (room.question) return room;
            room.state = 'playing';
            room.question = chooseRandomQuestion();
            return room;
          });
        }
      }

      tick();
      sharedTimerInterval = setInterval(tick, 300);
    }

    function startBattleTimer(q) {
      clearSharedTimer();
      if (!q || !q.startTime) return;
      currentQuestionStartTime = q.startTime;
      timerMode = 'question';
      timerBadge.style.display = 'inline-flex';

      function tick() {
        if (timerMode !== 'question' || !roomRef || !currentQuestionId || q.id !== currentQuestionId) {
          clearSharedTimer();
          return;
        }
        const now = Date.now();
        const remaining = Math.max(0, BATTLE_TIME_LIMIT_MS - (now - currentQuestionStartTime));
        const seconds = Math.ceil(remaining / 1000);
        timerText.textContent = seconds + 's';

        if (remaining <= 0) {
          clearSharedTimer();
          handleBattleTimeout(q);
        }
      }

      tick();
      sharedTimerInterval = setInterval(tick, 250);
    }

    function handleBattleTimeout(q) {
      const optionButtons = Array.from(optionsContainer.querySelectorAll('.option-btn'));
      optionButtons.forEach(b => { b.disabled = true; });

      roomRef.transaction(function (room) {
        if (!room || !room.question || room.question.id !== q.id || !room.players) return room;
        const ids = Object.keys(room.players);
        ids.forEach(id => {
          const p = room.players[id];
          if (!p.alive) return;
          if (p.answeredId === q.id) return;
          p.alive = false;
          p.answeredId = q.id;
        });

        const aliveIds = ids.filter(id => room.players[id].alive);
        const aliveCount = aliveIds.length;

        if (aliveCount <= 1) {
          room.state = 'finished';
          room.winnerId = aliveIds[0] || null;
          return room;
        }

        room.question = chooseRandomQuestion();
        return room;
      });
    }

    // === Single player helpers ===
    function resetSingleState() {
      singleLives = 3;
      singleScore = 0;
      singleQuestion = null;
      updateSingleScoreUI();
      timeAttackLeaderboard.style.display = 'none';
      restartTimeAttackBtn.style.display = 'none';
      stopTimeAttackTimer();
    }

    function updateSingleScoreUI() {
      singleScoreValue.textContent = singleScore;
      if (singleMode === 'lives3') {
        singleLivesTitle.textContent = 'Lives';
        singleLivesNote.textContent = 'Max 3 lives';
        const hearts = '‚ù§Ô∏è'.repeat(singleLives) + 'ü§ç'.repeat(Math.max(0, 3 - singleLives));
        singleLivesValue.textContent = hearts;
      } else {
        singleLivesTitle.textContent = 'Mode';
        singleLivesNote.textContent = 'Time Attack (1:30)';
        singleLivesValue.textContent = '‚è±Ô∏è';
      }
    }

    function nextSingleQuestion() {
      singleQuestion = chooseRandomQuestion();
      currentQuestionId = singleQuestion.id;
      if (singleMode === 'lives3') {
        questionTitle.textContent = 'Guess the flag! You have 3 lives.';
      } else {
        questionTitle.textContent = 'Time Attack: guess as many flags as you can!';
      }
      renderQuestion(singleQuestion, null);
    }

    function startSinglePlayer() {
      // close online rooms
      if (roomRef) {
        roomRef.off();
        roomRef = null;
      }
      roomCode = null;
      playerNumber = null;
      playerKey = null;
      lastKnownMeAlive = true;
      clearSharedTimer();

      const rawName = playerNameInput.value.trim();
      singlePlayerName = rawName || getPlayerNameFallback();
      gameMode = 'single';
      resetSingleState();

      showGameUI();
      scoresDuel.style.display = 'none';
      battleStatusEl.style.display = 'none';
      battlePlayersList.style.display = 'none';
      scoresSingle.style.display = 'flex';
      turnBadge.textContent = (singleMode === 'lives3') ? 'Single player ‚Äì 3 lives' : 'Single player ‚Äì Time Attack';
      gameMessage.textContent = '';

      if (singleMode === 'timeAttack') {
        startTimeAttackTimer();
      }

      nextSingleQuestion();
    }

    function startTimeAttackTimer() {
      stopTimeAttackTimer();
      timeAttackEndTime = Date.now() + TIME_ATTACK_MS;
      timerBadge.style.display = 'inline-flex';

      function tick() {
        if (!timeAttackEndTime || gameMode !== 'single' || singleMode !== 'timeAttack') {
          stopTimeAttackTimer();
          return;
        }
        const remaining = Math.max(0, timeAttackEndTime - Date.now());
        const seconds = Math.ceil(remaining / 1000);
        timerText.textContent = seconds + 's';
        if (remaining <= 0) {
          stopTimeAttackTimer();
          endTimeAttackGame();
        }
      }

      tick();
      timeAttackInterval = setInterval(tick, 250);
    }

    function todayKey() {
      const d = new Date();
      return d.toISOString().slice(0,10); // YYYY-MM-DD
    }

    function sanitizeName(name) {
      if (!name || !name.trim()) return 'Player';
      return name.replace(/[.#$/\[\]]/g, '_').trim();
    }

    function endTimeAttackGame() {
      answeringLocked = true;
      const optionButtons = Array.from(optionsContainer.querySelectorAll('.option-btn'));
      optionButtons.forEach(b => { b.disabled = true; });

      gameMessage.textContent = 'Time is up! You guessed ' + singleScore + ' flags.';

      saveTimeAttackScore(singlePlayerName, singleScore)
        .then(loadTimeAttackLeaderboard)
        .catch(() => loadTimeAttackLeaderboard());

      restartTimeAttackBtn.style.display = 'inline-flex';
    }

    function saveTimeAttackScore(name, score) {
      const day = todayKey();
      const key = sanitizeName(name);
      const ref = db.ref('leaderboards/timeAttack/' + day + '/' + key);
      return ref.transaction(current => {
        if (!current || typeof current.bestScore !== 'number' || score > current.bestScore) {
          return { bestScore: score, updatedAt: Date.now() };
        }
        return current;
      });
    }

    function loadTimeAttackLeaderboard() {
      const day = todayKey();
      const ref = db.ref('leaderboards/timeAttack/' + day);
      return ref.once('value').then(snapshot => {
        const data = snapshot.val() || {};
        const entries = Object.keys(data).map(name => ({
          name,
          score: data[name].bestScore || 0
        }));
        entries.sort((a, b) => b.score - a.score);
        const top5 = entries.slice(0, 5);

        leaderboardDate.textContent = day;
        leaderboardList.innerHTML = top5.length
          ? top5.map((e, index) => `
              <li>
                <span class="name">${index + 1}. ${e.name}</span>
                <span>${e.score}</span>
              </li>`).join('')
          : '<li><span>No scores yet today.</span></li>';

        timeAttackLeaderboard.style.display = 'block';
      });
    }

    // === Room / online logic ===
    async function createRoom() {
      const selected = getSelectedMode();
      if (selected === 'single') {
        startSinglePlayer();
        return;
      }

      if (roomRef) return;

      if (selected === 'duel') {
        await createRoomDuel();
      } else {
        await createRoomBattlePrivate();
      }
    }

    async function createRoomDuel() {
      try {
        createStatus.textContent = 'Creating room...';
        const code = randomRoomCode();
        roomCode = code;
        roomRef = db.ref('rooms/' + code);

        const initialQuestion = chooseRandomQuestion();
        const rawName = playerNameInput.value.trim();
        const name = rawName || 'Player 1';

        await roomRef.set({
          code: code,
          mode: 'duel',
          createdAt: Date.now(),
          state: 'waiting',
          currentPlayer: 1,
          question: initialQuestion,
          scores: { p1: 0, p2: 0 },
          players: {
            p1: { joined: true, name: name },
            p2: { joined: false, name: null }
          }
        });

        playerNumber = 1;
        playerKey = null;
        gameMode = 'duel';
        setupRoomListener();
        createStatus.textContent = 'Room created! Wait for Player 2 to join.';
        roomCodeLabel.textContent = 'Code: ' + code;
        showGameUI();
      } catch (err) {
        console.error(err);
        createStatus.textContent = 'Error creating room.';
      }
    }

    async function createRoomBattlePrivate() {
      try {
        createStatus.textContent = 'Creating room...';
        const code = randomRoomCode();
        roomCode = code;
        roomRef = db.ref('rooms/' + code);

        const rawName = playerNameInput.value.trim();
        const myName = rawName || getPlayerNameFallback();

        const now = Date.now();

        await roomRef.set({
          code: code,
          mode: 'battle',
          createdAt: now,
          state: 'lobby',
          lobbyStartTime: now,
          question: null,
          players: {}
        });

        playerKey = roomRef.child('players').push().key;
        await roomRef.child('players/' + playerKey).set({
          joined: true,
          alive: true,
          score: 0,
          name: myName
        });

        playerNumber = null;
        lastKnownMeAlive = true;
        gameMode = 'battle';
        setupRoomListener();
        createStatus.textContent = 'Battle Royale room created! Wait for the countdown.';
        roomCodeLabel.textContent = 'Code: ' + code;
        showGameUI();
      } catch (err) {
        console.error(err);
        createStatus.textContent = 'Error creating room.';
      }
    }

    async function joinRoom() {
      if (getSelectedMode() === 'single') {
        joinStatus.textContent = 'Single player mode does not use rooms.';
        return;
      }

      try {
        const code = joinCodeInput.value.trim();
        if (!code) {
          joinStatus.textContent = 'Enter a room code.';
          return;
        }

        joinStatus.textContent = 'Searching room...';
        const ref = db.ref('rooms/' + code);
        const snapshot = await ref.once('value');

        if (!snapshot.exists()) {
          joinStatus.textContent = 'Room not found.';
          return;
        }

        const data = snapshot.val();
        const mode = data.mode || 'duel';
        roomCode = code;
        roomRef = ref;

        const rawName = playerNameInput.value.trim();

        if (mode === 'duel') {
          gameMode = 'duel';
          if (data.players && data.players.p2 && data.players.p2.joined) {
            joinStatus.textContent = 'Room is already full.';
            roomRef = null;
            return;
          }

          playerNumber = 2;
          playerKey = null;
          const name = rawName || 'Player 2';
          await roomRef.child('players/p2').set({ joined: true, name: name });
          await roomRef.child('state').set('playing');
        } else {
          gameMode = 'battle';
          if (data.state === 'finished') {
            joinStatus.textContent = 'This game is already finished.';
            roomRef = null;
            return;
          }

          const myName = rawName || getPlayerNameFallback();
          playerKey = roomRef.child('players').push().key;
          await roomRef.child('players/' + playerKey).set({
            joined: true,
            alive: true,
            score: 0,
            name: myName
          });
          playerNumber = null;
          lastKnownMeAlive = true;
        }

        joinStatus.textContent = 'You joined the room!';
        setupRoomListener();
        showGameUI();
      } catch (err) {
        console.error(err);
        joinStatus.textContent = 'Error joining room.';
      }
    }

    async function joinPublicBattle() {
      if (getSelectedMode() === 'single') {
        publicBattleStatus.textContent = 'Single player mode does not use rooms.';
        return;
      }

      try {
        publicBattleStatus.textContent = 'Looking for a public room...';
        const ref = db.ref('publicBattle/room');
        let snap = await ref.once('value');
        let data = snap.val();

        if (!data || data.state === 'finished') {
          await ref.set({
            mode: 'battlePublic',
            createdAt: Date.now(),
            state: 'waiting',
            lobbyStartTime: null,
            question: null,
            players: {}
          });
          snap = await ref.once('value');
          data = snap.val();
        }

        if (data.state === 'playing') {
          publicBattleStatus.textContent = 'A public game is already in progress, try again soon.';
          return;
        }

        const players = data.players || {};
        const ids = Object.keys(players);
        const total = ids.length;

        if (total >= PUBLIC_MAX_PLAYERS) {
          publicBattleStatus.textContent = 'The public room is full, try again soon.';
          return;
        }

        const rawName = playerNameInput.value.trim();
        const myName = rawName || getPlayerNameFallback();

        const newKey = ref.child('players').push().key;
        await ref.child('players/' + newKey).set({
          joined: true,
          alive: true,
          score: 0,
          name: myName
        });

        await ref.transaction(function (room) {
          if (!room) return room;
          const p = room.players || {};
          const idsNow = Object.keys(p);
          if (room.state === 'waiting' && idsNow.length >= PUBLIC_MIN_PLAYERS) {
            room.state = 'lobby';
            room.lobbyStartTime = Date.now();
          }
          return room;
        });

        playerKey = newKey;
        playerNumber = null;
        roomRef = ref;
        roomCode = 'PUB';
        gameMode = 'battlePublic';
        lastKnownMeAlive = true;
        publicBattleStatus.textContent = 'You joined the public Battle Royale!';
        setupRoomListener();
        showGameUI();
      } catch (e) {
        console.error(e);
        publicBattleStatus.textContent = 'Error joining the public Battle Royale.';
      }
    }

    function showGameUI() {
      gameContainer.style.display = 'block';

      if (gameMode === 'duel' && playerNumber) {
        playerLabel.textContent = 'Player ' + playerNumber;
      } else if (gameMode === 'single') {
        playerLabel.textContent = singlePlayerName || 'Player';
      } else {
        playerLabel.textContent = '-';
      }

      roomCodeDisplay.textContent =
        gameMode === 'single' ? 'Offline' : (roomCode || '');
    }

    function setupRoomListener() {
      if (!roomRef) return;

      roomRef.on('value', function (snapshot) {
        const data = snapshot.val();
        if (!data) {
          gameMessage.textContent = 'The room has been closed.';
          clearSharedTimer();
          return;
        }

        const mode = data.mode || 'duel';
        if (mode === 'duel') {
          gameMode = 'duel';
          clearSharedTimer();
          updateDuelUI(data);
        } else {
          gameMode = (mode === 'battlePublic') ? 'battlePublic' : 'battle';
          updateBattleUI(data);
        }
      });
    }

    function updateDuelUI(data) {
      scoresDuel.style.display = 'flex';
      scoresSingle.style.display = 'none';
      battleStatusEl.style.display = 'none';
      battlePlayersList.style.display = 'none';
      clearSharedTimer();

      const s1 = data.scores && typeof data.scores.p1 === 'number' ? data.scores.p1 : 0;
      const s2 = data.scores && typeof data.scores.p2 === 'number' ? data.scores.p2 : 0;
      score1El.textContent = s1;
      score2El.textContent = s2;

      const current = data.currentPlayer || 1;
      turnBadge.textContent = 'Turn: Player ' + current;

      if (current === 1) {
        scoreP1.classList.add('active');
        scoreP2.classList.remove('active');
      } else {
        scoreP2.classList.add('active');
        scoreP1.classList.remove('active');
      }

      const p1Joined = data.players && data.players.p1 && data.players.p1.joined;
      const p2Joined = data.players && data.players.p2 && data.players.p2.joined;

      if (data.players) {
        if (data.players.p1 && data.players.p1.name) {
          document.getElementById('scoreNote1').textContent = data.players.p1.name;
        }
        if (data.players.p2 && data.players.p2.name) {
          document.getElementById('scoreNote2').textContent = data.players.p2.name;
        }
      }

      if (playerNumber) {
        if (playerNumber === 1 && data.players && data.players.p1 && data.players.p1.name) {
          playerLabel.textContent = data.players.p1.name;
        } else if (playerNumber === 2 && data.players && data.players.p2 && data.players.p2.name) {
          playerLabel.textContent = data.players.p2.name;
        } else {
          playerLabel.textContent = 'Player ' + playerNumber;
        }
      }

      if (!p1Joined || !p2Joined) {
        questionTitle.textContent = 'Waiting for both players to join...';
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        return;
      }

      if (data.state !== 'playing') {
        questionTitle.textContent = 'Waiting to start...';
        return;
      }

      const q = data.question;
      if (!q) return;

      if (currentQuestionId !== q.id) {
        currentQuestionId = q.id;
        renderQuestion(q, data.currentPlayer);
      }
    }

    function updateBattleUI(data) {
      scoresDuel.style.display = 'none';
      scoresSingle.style.display = 'none';
      battleStatusEl.style.display = 'flex';
      battlePlayersList.style.display = 'block';

      const players = data.players || {};
      const ids = Object.keys(players);
      const total = ids.length;

      const aliveIds = ids.filter(id => players[id].alive);
      const aliveCount = aliveIds.length;

      lastKnownMeAlive = playerKey && players[playerKey] ? !!players[playerKey].alive : false;

      battlePlayersValue.textContent = aliveCount + " / " + total;

      if (playerKey && players[playerKey] && players[playerKey].name) {
        playerLabel.textContent = players[playerKey].name;
      } else {
        playerLabel.textContent = '-';
      }

      const arr = ids.map(id => {
        const p = players[id];
        return {
          id,
          name: p.name || 'Player ?',
          score: p.score || 0,
          alive: !!p.alive
        };
      });

      arr.sort((a, b) => {
        if (a.alive !== b.alive) return a.alive ? -1 : 1;
        return (b.score || 0) - (a.score || 0);
      });

      battlePlayersList.innerHTML = arr.map(p => {
        const classes = [
          'battle-player',
          p.alive ? 'alive' : 'dead',
          (p.id === playerKey) ? 'me' : ''
        ].join(' ');
        const statusLabel = p.alive ? 'alive' : 'eliminated';
        return `
          <div class="${classes}">
            <div>
              <span class="battle-player-name">${p.name}</span>
              <span class="battle-player-status">(${statusLabel})</span>
            </div>
            <div class="battle-player-score">${p.score}</div>
          </div>
        `;
      }).join('');

      let extra = '';
      if (data.state === 'finished') {
        if (data.winnerId && players[data.winnerId]) {
          const winnerName = players[data.winnerId].name || 'Player';
          extra = winnerName + ' wins!';
        } else {
          extra = 'No winner.';
        }
        turnBadge.textContent = 'Game finished';
      } else {
        extra = 'Players alive: ' + aliveCount + ' / ' + total;
        turnBadge.textContent = 'Battle Royale';
      }
      battleExtra.textContent = extra;

      if (total === 0) {
        questionTitle.textContent = 'Waiting for players to join the Battle Royale...';
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        clearSharedTimer();
        return;
      }

      if (data.state === 'waiting') {
        questionTitle.textContent = 'Waiting for players to join the Battle Royale...';
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        clearSharedTimer();
        return;
      }

      if (data.state === 'lobby') {
        questionTitle.textContent = 'The Battle Royale is about to start...';
        flagImg.src = '';
        optionsContainer.innerHTML = '';
        if (data.lobbyStartTime) {
          startLobbyTimer(data.lobbyStartTime);
        }
        return;
      }

      if (data.state !== 'playing') {
        clearSharedTimer();
        if (data.state === 'finished') {
          if (playerKey && data.winnerId && data.winnerId === playerKey) {
            gameMessage.textContent = 'You won the Battle Royale! üèÜ';
          } else if (playerKey) {
            gameMessage.textContent = 'You have been eliminated from the Battle Royale.';
          }
        }
        return;
      }

      const q = data.question;
      if (!q) return;

      if (currentQuestionId !== q.id) {
        currentQuestionId = q.id;
        currentQuestionStartTime = q.startTime || Date.now();
        renderQuestion(q, null);
        startBattleTimer(q);
      }

      if (!lastKnownMeAlive && data.state === 'playing') {
        gameMessage.textContent = 'You have been eliminated. You can watch the rest of the game.';
        answeringLocked = true;
        Array.from(optionsContainer.querySelectorAll('.option-btn')).forEach(b => {
          b.disabled = true;
        });
      }
    }

    function renderQuestion(q, currentPlayer) {
      answeringLocked = false;
      gameMessage.textContent = '';

      if (gameMode === 'duel') {
        questionTitle.textContent = 'Which country does this flag belong to?';
      } else if (gameMode === 'single') {
        if (singleMode === 'lives3') {
          questionTitle.textContent = 'Guess the flag! You have 3 lives.';
        } else {
          questionTitle.textContent = 'Time Attack: guess as many flags as you can!';
        }
      } else {
        questionTitle.textContent = 'Guess the flag: you have 10 seconds!';
      }

      flagImg.src = 'https://flagcdn.com/w320/' + q.correctCode + '.png';
      flagImg.alt = 'Flag';

      optionsContainer.innerHTML = '';

      q.options.forEach(function (opt, index) {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.textContent = opt.name || ('Option ' + (index + 1));
        btn.dataset.correct = (opt.code === q.correctCode) ? 'true' : 'false';
        btn.addEventListener('click', function () {
          onAnswerClick(btn, q, currentPlayer);
        });
        optionsContainer.appendChild(btn);
      });

      if (gameMode === 'duel' && playerNumber !== currentPlayer) {
        gameMessage.textContent = "It's the other player's turn.";
      }
    }

    async function onAnswerClick(btn, q, currentPlayer) {
      if (answeringLocked) return;

      if (gameMode === 'duel' && playerNumber !== currentPlayer) {
        return;
      }

      const isCorrect = btn.dataset.correct === 'true';
      const optionButtons = Array.from(optionsContainer.querySelectorAll('.option-btn'));

      // Single player logic
      if (gameMode === 'single') {
        answeringLocked = true;

        optionButtons.forEach(function (b) {
          if (b.dataset.correct === 'true') {
            b.classList.add('correct');
          } else if (b === btn && !isCorrect) {
            b.classList.add('wrong');
          }
          b.disabled = true;
        });

        if (singleMode === 'lives3') {
          if (isCorrect) {
            gameMessage.textContent = 'Correct! üéâ';
            singleScore += 1;
          } else {
            singleLives -= 1;
            if (singleLives <= 0) {
              updateSingleScoreUI();
              gameMessage.textContent = 'Game over! Final score: ' + singleScore;
              return;
            } else {
              gameMessage.textContent = 'Wrong! It was: ' + q.correctName;
            }
          }
          updateSingleScoreUI();
          setTimeout(function () {
            nextSingleQuestion();
          }, 900);
        } else {
          // Time Attack: no lives, just score
          if (isCorrect) {
            gameMessage.textContent = 'Correct! üéâ';
            singleScore += 1;
          } else {
            gameMessage.textContent = 'Wrong! It was: ' + q.correctName;
          }
          updateSingleScoreUI();
          setTimeout(function () {
            if (gameMode === 'single' && singleMode === 'timeAttack' && timeAttackEndTime) {
              nextSingleQuestion();
            }
          }, 800);
        }
        return;
      }

      // BATTLE: time check
      if (gameMode === 'battle' || gameMode === 'battlePublic') {
        const now = Date.now();
        const base = q.startTime || currentQuestionStartTime || now;
        if (now - base > BATTLE_TIME_LIMIT_MS) {
          answeringLocked = true;
          gameMessage.textContent = 'Wrong or too late! You are eliminated.';
          optionButtons.forEach(b => { b.disabled = true; });
          setTimeout(function () {
            roomRef.transaction(function (room) {
              if (!room || !room.players || !playerKey) return room;
              const me = room.players[playerKey];
              if (!me || !me.alive) return room;
              me.alive = false;
              me.answeredId = q.id;
              const ids = Object.keys(room.players);
              const aliveIds = ids.filter(id => room.players[id].alive);
              if (aliveIds.length <= 1) {
                room.state = 'finished';
                room.winnerId = aliveIds[0] || null;
              }
              return room;
            });
          }, 400);
          return;
        }
      }

      // Highlight answers
      answeringLocked = true;
      optionButtons.forEach(function (b) {
        if (b.dataset.correct === 'true') {
          b.classList.add('correct');
        } else if (b === btn && !isCorrect) {
          b.classList.add('wrong');
        }
        b.disabled = true;
      });

      if (gameMode === 'duel') {
        if (isCorrect) {
          gameMessage.textContent = 'Correct! üéâ';
        } else {
          gameMessage.textContent = 'Wrong! It was: ' + q.correctName;
        }

        setTimeout(function () {
          roomRef.transaction(function (room) {
            if (!room) return room;
            if (room.question && room.question.id !== q.id) {
              return room;
            }

            room.scores = room.scores || { p1: 0, p2: 0 };

            if (isCorrect) {
              if (currentPlayer === 1) {
                room.scores.p1 = (room.scores.p1 || 0) + 1;
              } else {
                room.scores.p2 = (room.scores.p2 || 0) + 1;
              }
            }

            const newQ = chooseRandomQuestion();
            room.question = newQ;
            room.currentPlayer = currentPlayer === 1 ? 2 : 1;

            return room;
          });
        }, 900);
      } else if (gameMode === 'battle' || gameMode === 'battlePublic') {
        if (isCorrect) {
          gameMessage.textContent = 'Correct! You stay alive. üéâ';
        } else {
          gameMessage.textContent = 'Wrong or too late! You are eliminated.';
        }

        setTimeout(function () {
          roomRef.transaction(function (room) {
            if (!room) return room;
            if (!room.question || room.question.id !== q.id) return room;
            if (!room.players) return room;
            const me = room.players[playerKey];
            if (!me) return room;

            if (me.answeredId === q.id) return room;
            if (!me.alive) return room;

            if (isCorrect) {
              me.score = (me.score || 0) + 1;
            } else {
              me.alive = false;
            }
            me.answeredId = q.id;

            const ids = Object.keys(room.players);
            const aliveIds = ids.filter(id => room.players[id].alive);
            const aliveCount = aliveIds.length;

            if (aliveCount <= 1) {
              room.state = 'finished';
              room.winnerId = aliveIds[0] || null;
              return room;
            }

            const allAliveAnswered = aliveIds.every(id => room.players[id].answeredId === q.id);
            if (allAliveAnswered) {
              room.question = chooseRandomQuestion();
            }

            return room;
          });
        }, 900);
      }
    }

    async function leaveRoom() {
      if (!roomRef && gameMode !== 'single') return;

      try {
        if (gameMode === 'duel' && playerNumber && roomRef) {
          await roomRef.child('players/p' + playerNumber).set({ joined: false });
          if (playerNumber === 1) {
            await roomRef.remove();
          }
        } else if ((gameMode === 'battle' || gameMode === 'battlePublic') && playerKey && roomRef) {
          await roomRef.child('players/' + playerKey).update({ joined: false, alive: false });
        }
        gameMessage.textContent = 'You left the game.';
      } catch (e) {
        console.error(e);
      }

      clearSharedTimer();
      stopTimeAttackTimer();
      if (roomRef) {
        roomRef.off();
      }
      roomRef = null;
      roomCode = null;
      playerNumber = null;
      playerKey = null;
      currentQuestionId = null;
      lastKnownMeAlive = true;
      gameMode = getSelectedMode() === 'single' ? 'single' : 'duel';
      gameContainer.style.display = 'none';
      roomCodeLabel.textContent = '';
      createStatus.textContent = '';
      joinStatus.textContent = '';
      publicBattleStatus.textContent = '';
    }

    // === UI events ===
    createRoomBtn.addEventListener('click', function () {
      createRoom();
    });

    joinRoomBtn.addEventListener('click', function () {
      if (roomRef && gameMode !== 'single') return;
      joinRoom();
    });

    publicBattleBtn.addEventListener('click', function () {
      joinPublicBattle();
    });

    leaveBtn.addEventListener('click', function () {
      leaveRoom();
    });

    restartTimeAttackBtn.addEventListener('click', function () {
      // restart Time Attack
      singleMode = 'timeAttack';
      singlePills.forEach(p => {
        p.classList.toggle('active', p.dataset.singleMode === 'timeAttack');
      });
      startSinglePlayer();
    });

    modePills.forEach(pill => {
      pill.addEventListener('click', () => {
        const mode = pill.getAttribute('data-mode');
        modePills.forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        const input = pill.querySelector('input[name="mode"]');
        if (input) input.checked = true;

        if (mode === 'single') {
          startSinglePlayer();
        }
      });
    });

    singlePills.forEach(pill => {
      pill.addEventListener('click', () => {
        const mode = pill.getAttribute('data-single-mode');
        singleMode = mode;
        singlePills.forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        if (gameMode === 'single') {
          startSinglePlayer();
        }
      });
    });
  </script>
</body>
</html>
